This is gnugo.info, produced by makeinfo version 4.2 from gnugo.texi.

INFO-DIR-SECTION GNU games
START-INFO-DIR-ENTRY
* GNU go: (gnugo).          The GNU Go program
END-INFO-DIR-ENTRY


File: gnugo.info,  Node: Output File,  Next: Decide string,  Prev: Traces,  Up: Analyzing

The Output File
===============

   If GNU Go is invoked with the option `-o filename' it will produce
an output file. This option can be added at the command line in the Go
Modem Protocol Setup Window of CGoban. The output file will show the
locations of the moves considered and their weights. It is worth noting
that by enlarging the CGoban window to its fullest size it can display
3 digit numbers. Dragons with status `DEAD' are labelled with an `X',
and dragons with status `CRITICAL' are labelled with a `!'.

   If you have a game file which is not commented this way, or which
was produced by a non-current version of GNU Go you may ask GNU Go to
produce a commented version by running:

     gnugo --quiet -l <old file> --replay <color> -o <new file>

Here <color> can be 'black,' 'white' or 'both'. The replay option will
also help you to find out if your current version of GNU Go would play
differently than the program that created the file.


File: gnugo.info,  Node: Decide string,  Next: Decide dragon,  Prev: Output File,  Up: Analyzing

Checking the reading code
=========================

   The `--decide-string' option is used to check the tactical reading
code (*note Tactical Reading::). This option takes an argument, which
is a location on the board in the usual algebraic notation (e.g.
`--decide-string C17'). This will tell you whether the reading code (in
`engine/reading.c') believes the string can be captured, and if so,
whether it believes it can be defended, which moves it finds to attack
or defend the move, how many nodes it searched in coming to these
conclusions. Note that when GNU Go runs normally (not with
`--decide-string') the points of attack and defense are computed when
`make_worms()' runs and cached in `worm.attack' and `worm.defend'.

   If used with an output file (`-o FILENAME') `--decide-string' will
produce a variation tree showing all the variations which are
considered. This is a useful way of debugging the reading code, and
also of educating yourself with the way it works. The variation tree
can be displayed graphically using CGoban.

   At each node, the comment contains some information. For example you
may find a comment:


     attack4-B at D12 (variation 6, hash 51180fdf)
     break_chain D12: 0
     defend3 D12: 1 G12 (trivial extension)

   This is to be interpreted as follows. The node in question was
generated by the function `attack3()' in `engine/reading.c', which was
called on the string at `D12'. The data in parentheses tell you the
values of `count_variations' and `hashdata.hashval'.

   The second value ("hash") you probably will not need to know unless
you are debugging the hash code, and we will not discuss it.  But the
first value ("variation") is useful when using the debugger `gdb'. You
can first make an output file using the `-o' option, then walk through
the reading with `gdb', and to coordinate the SGF file with the
debugger, display the value of `count_variations'. Specifically, from
the debugger you can find out where you are as follows:

     (gdb) set dump_stack()
     B:D13 W:E12 B:E13 W:F12 B:F11  (variation 6)

   If you place yourself right after the call to `trymove()' which
generated the move in question, then the variation number in the SGF
file should match the variation number displayed by `dump_stack()', and
the move in question will be the last move played (F11 in this example).

   This displays the sequence of moves leading up to the variation in
question, and it also prints `count_variations-1'.

   The second two lines tell you that from this node, the function
`break_chain()' was called at D12 and returned 0 meaning that no way
was found of rescuing the string by attacking an element of the
surrounding chain, and the function `defend3()' was called also at D12
and returned 1, meaning that the string can be defended, and that G12
is the move that defends it. If you have trouble finding the function
calls which generate these comments, try setting `sgf_dumptree=1' and
setting a breakpoint in `sgf_trace'.


File: gnugo.info,  Node: Decide dragon,  Next: GTP and GDB techniques,  Prev: Decide string,  Up: Analyzing

Checking the Owl code
=====================

   You can similarly debug the Owl code using the option
`--decide-dragon'. Usage is entirely similar to `--decide-string', and
it can be used similarly to produce variation trees. These should be
typically much smaller than the variation trees produced by
`--decide-string'.


File: gnugo.info,  Node: GTP and GDB techniques,  Next: Debugboard,  Prev: Decide dragon,  Up: Analyzing

GTP and GDB techniques
======================

   You can use the Go Text Protocol (*note GTP::) to determine the
statuses of dragons and other information needed for debugging. The GTP
command `dragon_data P12' will list the dragon data of the dragon at
`P12' and `worm_data' will list the worm data; other GTP commands may
be useful as well.

   You can also conveniently get such information from GDB.  A
suggested `.gdbinit' file may be found in *Note Debugging::. Assuming
this file is loaded, you can list the dragon data with the command:

     (gdb) dragon P12

   Similarly you can get the worm data with `worm P12'.


File: gnugo.info,  Node: Debugboard,  Next: Scoring,  Prev: GTP and GDB techniques,  Up: Analyzing

Debugboard
==========

   A useful utility called `debugboard' is made in the
`interface/debugboard/' directory. This can be run in an Xterm. Use a
smaller font since it requires 50 rows and 80 columns. This runs
`examine_position()', then makes a graphical display of the board.
Using the cursor movement keys, you can move around the board and find
out the contents of the worm, dragon and eye arrays.


File: gnugo.info,  Node: Scoring,  Next: Colored Display,  Prev: Debugboard,  Up: Analyzing

Scoring the game
================

   GNU Go can score the game. Normally GNU Go will report its opinion
about the score at the end of the game, but if you want this
information about a game stored in a file, use the `--score' option
(*note Invoking GNU Go::).


File: gnugo.info,  Node: Colored Display,  Prev: Scoring,  Up: Analyzing

Colored Display
===============

   Various colored displays of the board may be obtained in a color
`xterm' or `rxvt' window. Xterm will only work if xterm is compiled
with color support. If the colors are not displayed on your xterm, try
`rxvt'.  You may also use the Linux console. The colored display will
work best if the background color is black; if this is not the case you
may want to edit your `.Xdefaults' file or add the options `-bg black
-fg white' to `xterm' or `rxvt'.  On Mac OS X put `setenv TERM
xterm-color' in your `.tcshrc' file to enable color in the terminal.

Dragon Display
--------------

   You can get a colored ASCII display of the board in which each dragon
is assigned a different letter; and the different `matcher_status'
values (`ALIVE', `DEAD', `UNKNOWN', `CRITICAL') have different colors.
This is very handy for debugging. Actually two diagrams are generated.
The reason for this is concerns the way the matcher status is computed.
The dragon_status (*note Dragons::) is computed first, then for some,
but not all dragons, a more accurate owl status is computed. The
matcher status is the owl status if available; otherwise it is the
dragon_status. Both the dragon_status and the owl_status are displayed.
The color scheme is as follows:

     green = alive
     cyan = dead
     red = critical
     yellow = unknown
     magenta = unchecked

   To get the colored display, save a game in sgf format using CGoban,
or using the `-o' option with GNU Go itself.

   Open an `xterm' or `rxvt' window.

   Execute `gnugo -l [filename] -L [movenum] -T' to get the colored
display.

   Other useful colored displays may be obtained by using instead:

Eye Space Display
-----------------

   Instead of `-T', try this with `-E'. This gives a colored display of
the eyespaces, with marginal eye spaces marked `!' (*note Eyes::).

Moyo Display
------------

   The option `-m LEVEL' can give colored displays of the various
quantities which are computed in `engine/moyo.c'.

   GNU Go contains two distinct implementations of the concepts of
Territory, Moyo and Area (*note Territory and Moyo::). Primarily GNU Go
computes Territory, Moyo and Area using the influence code, and reports
them with the functions `whose_territory()', `whose_moyo()' and
`whose_area()'. To get a colored display of the influence regions found
by this module, use `-m 0x18' to see the initial influence, and e.g.
`-m 0x10 --debug-influence D5' to see the influence after having made
the move D5. There are various other options available for numerical
displays influence; for a detailed description see *Note Influential
Display::.

   The regions found by Bouzy's algorithm (*note Alternative Moyo::) are
used only in the function `estimate_score()'. These can be displayed
with the following options:

     `-m LEVEL'
      use or (hexadecimal)   cumulative values for printing these reports :
         1       0x01         ascii printing of territorial evaluation (5/21)
         2       0x02         ascii printing of moyo evaluation (5/10)
         4       0x04         ascii printing of area (4/0)

The `-m' options can be combined by adding the levels.


File: gnugo.info,  Node: Move Generation,  Next: Worms and Dragons,  Prev: Analyzing,  Up: Top

Move generation
***************

* Menu:

* Move generation Intro::	Introduction.
* Move Reasons::		Generation of move reasons.
* Move Reason Details::		Detailed Descriptions of Move Reasons
* Valuation:: 			Valuating the moves
* End Game::			Endgame move generation


File: gnugo.info,  Node: Move generation Intro,  Next: Move Reasons,  Up: Move Generation

Introduction
============

   GNU Go 3.0 introduced a move generation scheme substantially
different from earlier versions. In particular, it was different from
the method of move generation in GNU Go 2.6.

   In the old scheme, various move generators suggested different moves
with attached values. The highest such value then decided the move.
There were two important drawbacks with this scheme:

   * Efficient multipurpose moves could only be found by patterns which
     explicitly looked for certain combinations, such as a simultaneous
     connection and cut. There was also no good way to e.g. choose among
     several attacking moves.

   * The absolute move values were increasingly becoming harder to tune
     with the increasing number of patterns. They were also fairly
     subjective and the tuning could easily break in unexpected ways
     when something changed, e.g. the worm valuation.

   The basic idea of the new move generation scheme is that the various
move generators suggest reasons for moves, e.g. that a move captures
something or connects two strings, and so on. When all reasons for the
different moves have been found, the valuation starts. The primary
advantages are

   * The move reasons are objective, in contrast to the move values in
     the old scheme. Anyone can verify whether a suggested move reason
     is correct.

   * The centralized move valuation makes tuning easier. It also allows
     for style dependent tuning, e.g. how much to value influence
     compared to territory. Another possibility is to increase the value
     of safe moves in a winning position.


File: gnugo.info,  Node: Move Reasons,  Next: Move Reason Details,  Prev: Move generation Intro,  Up: Move Generation

Generation of move reasons
==========================

   Each move generator suggests a number of moves.  It justifies each
move suggestion with one or move "move reasons".  These move reasons
are collected at each intersection where the moves are suggested for
later valuation.  A partial list of of move reasons considered by GNU
Go are:

`ATTACK_MOVE'
`DEFEND_MOVE'
     Attack or defend a worm.

`ATTACK_THREAT_MOVE'
`DEFEND_THREAT_MOVE'
     Threaten to attack or defend a worm.

`EITHER_MOVE'
     A move that either achieves one goal or another (at the moment
     this only used for attacks on worms).

`ALL_MOVE'
     At the moment this is used for a move that defends two worms
     threatened by a double attack.

`CONNECT_MOVE'
`CUT_MOVE'
     Connect or cut two worms.

`ANTISUJI_MOVE'
     Declare an antisuji or forbidden move.

`SEMEAI_MOVE'
`SEMEAI_THREAT'
     Win or threaten to win a semeai.

`EXPAND_TERRITORY_MOVE'

`EXPAND_MOYO_MOVE'
     Move expanding our territory/moyo. These reasons are at the moment
     treated identically.

`VITAL_EYE_MOVE'
     A vital point for life and death.

`STRATEGIC_ATTACK_MOVE'
`STRATEGIC_DEFEND_MOVE'
     Moves added by 'a' and 'd' class patterns (*note Pattern
     Classification::) which (perhaps intangibly) attack or defend a
     dragon.

`OWL_ATTACK_MOVE'
`OWL_DEFEND_MOVE'
     An owl attack or defense move.

`OWL_ATTACK_THREAT'
`OWL_DEFEND_THREAT'
     A threat to owl attack or defend a group.

`OWL_PREVENT_THREAT'
     A move to remove an owl threat.

`UNCERTAIN_OWL_ATTACK'
`UNCERTAIN_OWL_DEFENSE'
     An uncertain owl attack or defense. This means that the owl code
     could not decide the outcome, because the owl node limit was
     reached.

`MY_ATARI_ATARI_MOVE'
     A move that starts a chain of ataris, eventually leading to a
     capture.

`YOUR_ATARI_ATARI_MOVE'
     A move that if played by the opponent starts a chain of ataris for
     the opponent, leading to capture, which is also a safe move for
     us. Preemptively playing such a move almost always defends the
     threat.

   The attack and defend move types can have a suffix to denote moves
whose result depends on a ko, e.g. `OWL_ATTACK_MOVE_GOOD_KO'. Here
`..._GOOD_KO' and `..._BAD_KO' correspond to `KO_A' and `KO_B' as
explained in *Note Ko::.  See `engine/move_reasons.h' for the full of
move reasons.

   *NOTE:* Some of these are reasons for *not* playing a move.

   More detailed discussion of these move reasons will be found in the
next section.


File: gnugo.info,  Node: Move Reason Details,  Next: Valuation,  Prev: Move Reasons,  Up: Move Generation

Detailed Descriptions of various Move Reasons
=============================================

* Menu:

* Attack and Defense::             Worm Attack and Defense
* Threats to Attack or Defend::    Worm Threats
* Multi Attack or Defense::        Combined Attacks and Defenses
* Cutting and Connecting::         Cutting and Connecting moves
* Semeai::                         Semeai winning moves
* Making eyes::                    Vital eye moves
* Antisuji moves::                 Never play these!
* Territorial moves::              Block or expand territory
* Owl attack and defense::         Owl Attack and Defense
* Combination Attacks::            Coordinated threats such as double ataris


File: gnugo.info,  Node: Attack and Defense,  Next: Threats to Attack or Defend,  Up: Move Reason Details

Attacking and defending moves
-----------------------------

   A move which tactically captures a worm is called an "attack move"
and a move which saves a worm from being tactically captured is called a
"defense move". It is understood that a defense move can only exist if
the worm can be captured, and that a worm without defense only is
attacked by moves that decrease the liberty count or perform necessary
backfilling.

   It is important that all moves which attack or defend a certain
string are found, so that the move generation can make an informed
choice about how to perform a capture, or find moves which capture
and/or defend several worms.

   Attacking and defending moves are first found in `make_worms' while
it evaluates the tactical status of all worms, although this step only
gives one attack and defense (if any) move per worm. Immediately after,
still in `make_worms', all liberties of the attacked worms are tested
for additional attack and defense moves. More indirect moves are found
by `find_attack_patterns' and `find_defense_patterns', which match the
A (attack) and D (defense) class patterns in `patterns/attack.db' and
`patterns/defense.db' As a final step, all moves which fill some
purpose at all are tested whether they additionally attacks or defends
some worm. (Only unstable worms are analyzed.)


File: gnugo.info,  Node: Threats to Attack or Defend,  Next: Multi Attack or Defense,  Prev: Attack and Defense,  Up: Move Reason Details

Threats to Attack or Defend
---------------------------

   A threat to attack a worm, but where the worm can be defended is
used as a secondary move reason.  This move reason can enhance the
value of a move so that it becomes sente.  A threatening move without
any other justification can also be used as a ko threat.  The same is
true for a move that threatens defense of a worm, but where the worm
can still be captured if the attacker doesn't tenuki.

   Threats found by the owl code are called *owl threats* and they have
their own owl reasons.


File: gnugo.info,  Node: Multi Attack or Defense,  Next: Cutting and Connecting,  Prev: Threats to Attack or Defend,  Up: Move Reason Details

Multiple attack or defense moves
--------------------------------

   Sometimes a move attacks at least one of a number of worms or
simultaneously defends all of several worms. These moves are noted by
their own move reasons.


File: gnugo.info,  Node: Cutting and Connecting,  Next: Semeai,  Prev: Multi Attack or Defense,  Up: Move Reason Details

Cutting and connecting moves
----------------------------

   Moves which connect two distinct dragons are called `connecting
moves'.  Moves which prevent such connections are called "cutting
moves". Cutting and connecting moves are primarily found by pattern
matching, the `C' and `B' class patterns.

   A second source of cutting and connecting moves comes from the attack
and defense of cutting stones. A move which attacks a worm
automatically counts as a connecting move if there are multiple dragons
adjacent to the attacked worm. Similarly a defending move counts as a
cutting move. The action taken when a pattern of this type is found is
to induce a connect or cut move reason.

   When a cut or connect move reason is registered, the involved dragons
are of course stored. Thus the same move may cut and/or connect several
pairs of dragons.


File: gnugo.info,  Node: Semeai,  Next: Making eyes,  Prev: Cutting and Connecting,  Up: Move Reason Details

Semeai winning moves
--------------------

   A move which is necessary to win a capturing race is called a "semeai
move". These are similar to attacking moves, except that they involve
the simultaneous attack of one worm and the defense of another. As for
attack and defense moves, it's important that all moves which win a
semeai are found, so an informed choice can be made between them.

   Semeai move reasons should be set by the semeai module. However this
has not been implemented yet. One might also wish to list moves which
increase the lead in a semeai race (removes ko threats) for use as
secondary move reasons. Analogously if we are behind in the race.


File: gnugo.info,  Node: Making eyes,  Next: Antisuji moves,  Prev: Semeai,  Up: Move Reason Details

Making or destroying eyes
-------------------------

   A move which makes a difference in the number of eyes produced from
an eye space is called an "eye move". It's not necessary that the eye is
critical for the life and death of the dragon in question, although it
will be valued substantially higher if this is the case. As usual it's
important to find all moves that change the eye count.

   (This is part of what eye_finder was doing. Currently it only finds
one vital point for each unstable eye space.)


File: gnugo.info,  Node: Antisuji moves,  Next: Territorial moves,  Prev: Making eyes,  Up: Move Reason Details

Antisuji moves
--------------

   Moves which are locally inferior or for some other reason must not be
played are called "antisuji moves". These moves are generated by pattern
matching. Care must be taken with this move reason as the move under no
circumstances will be played.


File: gnugo.info,  Node: Territorial moves,  Next: Owl attack and defense,  Prev: Antisuji moves,  Up: Move Reason Details

Territorial moves
-----------------

   Any move that increases territory gets a move reason. This is the
expand territory move reason. That move reason is added by the `e'
patterns in `patterns/patterns.db'. Similarly the `E' patterns attempt
to generate or mitigate a moyo, which is a region of influence not yet
secure territory, yet valuable. Such a pattern sets the "expand moyo"
move reason.


File: gnugo.info,  Node: Owl attack and defense,  Next: Combination Attacks,  Prev: Territorial moves,  Up: Move Reason Details

Attacking and Defending Dragons
-------------------------------

   Just as the tactical reading code tries to determine when a worm can
be attacked or defended, the owl code tries to determine when a dragon
can get two eyes and live. The function `owl_reasons()' generates the
corresponding move reasons.

   The owl attack and owl defense move reasons are self explanatory.

   The owl attack threat reason is generated if owl attack on an
opponent's dragon fails but the owl code determines that the dragon can
be killed with two consecutive moves. The killing moves are stored in
`dragon[pos].owl_attack_point' and
`dragon[pos].owl_second_attack_point'.

   Similarly if a friendly dragon is dead but two moves can revive it,
an owl defense threat move reason is generated.

   The prevent threat reasons are similar but with the colors reversed:
if the opponent has an attack threat move then a move which removes the
threat gets a prevent threat move reason.

   The owl uncertain move reasons are generated when the owl code runs
out of nodes. In order to prevent the owl code from running too long, a
cap is put on the number of nodes one owl read can generate. If this is
exceeded, the reading is cut short and the result is cached as usual,
but marked uncertain.  In this case an owl uncertain move reason may be
generated.  For example, if the owl code finds the dragon alive but is
unsure, a move to defend may still be generated.


File: gnugo.info,  Node: Combination Attacks,  Prev: Owl attack and defense,  Up: Move Reason Details

Combination Attacks
-------------------

   The function `atari_atari' tries to find a sequence of ataris
culminating in an unexpected change of status of any opponent string,
from `ALIVE' to `CRITICAL'. Once such a sequence of ataris is found, it
tries to shorten it by rejecting irrelevant moves.


File: gnugo.info,  Node: Valuation,  Next: End Game,  Prev: Move Reason Details,  Up: Move Generation

Valuation of suggested moves
============================

   At the end of the move generation process, the function
`value_move_reasons()' tries to assign values to the moves for the
purpose of selecting the best move. The single purpose of the move
valuation is to try to rank the moves so that the best move gets the
highest score. In principle these values could be arbitrary, but in
order to make it easier to evaluate how well the valuation performs,
not to mention simplify the tuning, we try to assign values which are
consistent with the usual methods of counting used by human Go players,
as explained for example in _The Endgame_ by Ogawa and Davies.

   Moves are valued with respect to four different criteria. These are

   * territorial value

   * strategical value

   * shape value,

   * secondary value.

   All of these are floats and should be measured in terms of actual
points.

   The territorial value is the total change of expected territory
caused by this move. This includes changes in the status of groups if
the move is an attack or a defense move.

   Beginning with GNU Go 3.0, the influence function plays an important
role in estimating territory (*note Influence and Territory::). It is
used to make a guess at each intersection how likely it is that it will
become black or white territory. The territorial value sums up the
changes in these valuations.

   Strategical value is a measure of the effect the move has on the
safety of all groups on the board. Typically cutting and connecting
moves have their main value here. Also edge extensions, enclosing moves
and moves towards the center have high strategical value. The
strategical value should be the sum of a fraction of the territorial
value of the involved dragons. The fraction is determined by the change
in safety of the dragon.

   Shape value is a purely local shape analysis. An important role of
this measure is to offset mistakes made by the estimation of
territorial values. In open positions it's often worth sacrificing a
few points of (apparent) immediate profit to make good shape. Shape
value is implemented by pattern matching, the Shape patterns.

   Secondary value is given for move reasons which by themselves are not
sufficient to play the move. One example is to reduce the number of
eyes for a dragon that has several or to attack a defenseless worm.

   When all these values have been computed, they are summed, possibly
weighted (secondary value should definitely have a small weight), into
a final move value. This value is used to decide the move.

* Menu:

* Territorial value::		  How much territory does a move gain
* Strategical value::             Strategical gains from a move
* Shape factor::		  Local shape
* Minimum Value::                 Minimum value
* Secondary Value::               Other, more indirect, gains from a move
* Threats and Followup Value::    Valuation of attack and defense threats


File: gnugo.info,  Node: Territorial value,  Next: Strategical value,  Up: Valuation

Territorial Value
-----------------

   The algorithm for computing territorial value is in the function
`estimate_territorial_value'. As the name suggests, it seeks to
estimate the change in territory.

   It considers all groups that are changed from alive to death or
vice-versa due to this move. Also, it makes an assumption whether the
move should be considered safe. If so, the influence module is called:
The function `influence_delta_territory' estimates the territorial
effect of both the stone played and of the changes of group status'.

   The result returned by the influence module is subject to a number of
corrections. This is because some move reasons cannot be evaluated by a
single call to the influence function, such as moves depending on a ko.


File: gnugo.info,  Node: Strategical value,  Next: Shape factor,  Prev: Territorial value,  Up: Valuation

Strategical Value
-----------------

   Strategical defense or attack reasons are assigned to any move which
matches a pattern of type `a' or `d'. These are moves which in some
(often intangible) way tend to help strengthen or weaken a dragon. Of
course strengthening a dragon which is already alive should not be
given much value, but when the move reason is generated it is not
necessary to check its status or safety. This is done later, during the
valuation phase.


File: gnugo.info,  Node: Shape factor,  Next: Minimum Value,  Prev: Strategical value,  Up: Valuation

Shape Factor
------------

   In the value field of a pattern (*note Pattern Values::) one may
specify a shape value.

   This is used to compute the shape factor, which multiplies the score
of a move. We take the largest positive contribution to shape and add 1
for each additional positive contribution found.  Then we take the
largest negative contribution to shape, and add 1 for each additional
negative contribution. The resulting number is raised to the power 1.05
to obtain the shape factor.

   The rationale behind this complicated scheme is that every shape
point is very significant. If two shape contributions with values (say)
5 and 3 are found, the second contribution should be devalued to 1.
Otherwise the engine is too difficult to tune since finding multiple
contributions to shape can cause significant overvaluing of a move.


File: gnugo.info,  Node: Minimum Value,  Next: Secondary Value,  Prev: Shape factor,  Up: Valuation

Minimum Value
-------------

   A pattern may assign a minimum (and sometimes also a maximum) value.
For example the Joseki patterns have values which are prescribed in
this way, or ones with a `value' field.  One prefers not to use this
approach but in practice it is sometimes needed.

   In the fuseki, there are often several moves with identical minimum
value. GNU Go chooses randomly between such moves, which ensures some
indeterminacy of GNU Go's play. Later in the game, GNU Go's genuine
valuation of such a move is used as a secondary criterion.


File: gnugo.info,  Node: Secondary Value,  Next: Threats and Followup Value,  Prev: Minimum Value,  Up: Valuation

Secondary Value
---------------

   Secondary move reasons are weighed very slightly. Such a move can
tip the scales if all other factors are equal.


File: gnugo.info,  Node: Threats and Followup Value,  Prev: Secondary Value,  Up: Valuation

Threats and Followup Value
--------------------------

   Followup value refers to value which may acrue if we get two moves
in a row in a local area. It is assigned for moves that threaten to
attack or defend a worm or dragon. Also, since GNU Go 3.2 the influence
module makes an assessment of the possible purely territorial followup
moves.  In cases where these two heuristics are not sufficient we add
patterns with a `followup_value' autohelper macro.

   Usually, the followup value gives only a small contribution; e.g. if
it the followup value is very large, then GNU Go treats the move as
sente by doubling its value.  However, if the largest move on the board
is a ko which we cannot legally take, then such a move becomes
attractive as a ko threat and the full followup value is taken into
account.


File: gnugo.info,  Node: End Game,  Prev: Valuation,  Up: Move Generation

End Game
========

   Endgame moves are generated just like any other move by GNU Go. In
fact, the concept of endgame does not exist explicitly, but if the
largest move initially found is worth 6 points or less, an extra set of
patterns in `endgame.db' is matched and the move valuation is redone.


File: gnugo.info,  Node: Worms and Dragons,  Next: Eyes,  Prev: Move Generation,  Up: Top

Worms and Dragons
*****************

* Menu:

* Worms::                             Worms
* Amalgamation::                      How two Worms are amalgamated.
* Connection::                        Connections.
* Half Eyes::                         Half Eyes and False Eyes.
* Dragons::                           Union of WORMS.
* Dragons in Color::                  Colored display of DRAGONS.

   Before considering its move, GNU Go collects some data in several
arrays. Two of these arrays, called `worm' and `dragon', are discussed
in this document. Others are discussed in *Note Eyes::.

   This information is intended to help evaluate the connectedness, eye
shape, escape potential and life status of each group.

   Later routines called by `genmove()' will then have access to this
information. This document attempts to explain the philosophy and
algorithms of this preliminary analysis, which is carried out by the
two routines `make_worm()' and `make_dragon()' in `dragon.c'.

   A "worm" is a maximal set of stones on the board which are connected
along the horizontal and vertical lines, and are of the same color.  We
often say "string" instead of worm.

   A "dragon" is a union of strings of the same color which will be
treated as a unit. The dragons are generated anew at each move. If two
strings are in the dragon, it is the computer's working hypothesis that
they will live or die together and are effectively connected.

   The purpose of the dragon code is to allow the computer to formulate
meaningful statements about life and death.  To give one example,
consider the following situation:

           OOOOO
          OOXXXOO
          OX...XO
          OXXXXXO
           OOOOO

   The X's here should be considered a single group with one three-space
eye, but they consist of two separate strings.  Thus we must amalgamate
these two strings into a single dragon. Then the assertion makes sense,
that playing at the center will kill or save the dragon, and is a vital
point for both players. It would be difficult to formulate this
statement if the X's are not perceived as a unit.

   The present implementation of the dragon code involves simplifying
assumptions which can be refined in later implementations.


File: gnugo.info,  Node: Worms,  Next: Amalgamation,  Up: Worms and Dragons

Worms
=====

   The array `struct worm_data worm[MAX_BOARD]' collects information
about the worms. We will give definitions of the various fields. Each
field has constant value at each vertex of the worm. We will define
each field.


     struct worm_data {
       int color;
       int size;
       float effective_size;
       int origin;
       int liberties;
       int liberties2;
       int liberties3;
       int liberties4;
       int lunch;
       int cutstone;
       int cutstone2;
       int genus;
       int inessential;
       int invincible;
       int unconditional_status;
       int attack_points[MAX_TACTICAL_POINTS];
       int attack_codes[MAX_TACTICAL_POINTS];
       int defense_points[MAX_TACTICAL_POINTS];
       int defend_codes[MAX_TACTICAL_POINTS];
       int attack_threat_points[MAX_TACTICAL_POINTS];
       int attack_threat_codes[MAX_TACTICAL_POINTS];
       int defense_threat_points[MAX_TACTICAL_POINTS];
       int defense_threat_codes[MAX_TACTICAL_POINTS];
     };

   * `color'

          If the worm is `BLACK' or `WHITE', that is its color.
          Cavities (empty worms) have an additional attribute which we
          call "bordercolor". This will be one of `BLACK_BORDER',
          `WHITE_BORDER' or `GRAY_BORDER'. Specifically, if all the
          worms adjacent to a given empty worm have the same color
          (black or white) then we define that to be the bordercolor.
          Otherwise the bordercolor is gray.

          Rather than define a new field, we keep this data in the
          field color. Thus for every worm, the color field will have
          one of the following values: `BLACK', `WHITE', `GRAY_BORDER',
          `BLACK_BORDER' or `WHITE_BORDER'.  The last three categories
          are empty worms classified by bordercolor.

   * `size'

          This field contains the cardinality of the worm.

   * `effective_size'

          This is the number of stones in a worm plus the number of
          empty intersections that are at least as close to this worm
          as to any other worm. Intersections that are shared are
          counted with equal fractional values for each worm. This
          measures the direct territorial value of capturing a worm.
          "effective_size" is a floating point number.  Only
          intersections at a distance of 4 or less are counted.

   * `origin'

          Each worm has a distinguished member, called its "origin".
          The purpose of this field is to make it easy to determine
          when two vertices lie in the same worm: we compare their
          origin. Also if we wish to perform some test once for each
          worm, we simply perform it at the origin and ignore the other
          vertices. The origin is characterized by the test:
               worm[pos].origin == pos.

   * `liberties'

   * `liberties2'

   * `liberties3'

   * `liberties4'

          For a nonempty worm the field liberties is the number of
          liberties of the string. This is supplemented by
          `LIBERTIES2', `LIBERTIES3' and `LIBERTIES4', which are the
          number of second order, third order, and fourth order
          liberties, respectively.  The definition of liberties of
          order >1 is adapted to the problem of detecting the shape of
          the surrounding cavity. In particular we want to be able to
          see if a group is loosely surrounded. "a liberty of order n"
          is an empty vertex which may be connected to the string by
          placing n stones of the same color on the board, but no
          fewer. The path of connection may pass through an intervening
          group of the same color. The stones placed at distance >1 may
          not touch a group of the opposite color. Connections through
          ko are not permitted. Thus in the following configuration:

                         .XX...    We label the     .XX.4.
                         XO....    liberties of     XO1234
                         XO....    order < 5 of     XO1234
                         ......    the O group:     .12.4.
                         .X.X..                     .X.X..

          The convention that liberties of order >1 may not touch a
          group of the opposite color means that knight's moves and one
          space jumps are perceived as impenetrable barriers.  This is
          useful in determining when the string is becoming surrounded.

          The path may also not pass through a liberty at distance 1 if
          that liberty is flanked by two stones of the opposing color.
          This reflects the fact that the O stone is blocked from
          expansion to the left by the two X stones in the following
          situation:

                         X.
                         .O
                         X.
          We say that n is the "distance" of the liberty of order n
          from the dragon.

   * `lunch'

          If nonzero, `lunch' points to a boundary worm which can be
          easily captured.  (It does not matter whether or not the
          string can be defended.)

   We have two distinct notions of cutting stone, which we keep track
of in the separate fields `worm.cutstone' and `worm.cutstone2'.  We use
currently use both concepts in parallel.

   * `cutstone'

          This field is equal to 2 for cutting stones, 1 for potential
          cutting stones. Otherwise it is zero.  Definitions for this
          field: a "cutting stone" is one adjacent to two enemy
          strings, which do not have a liberty in common. The most
          common type of cutting string is in this situation:


                         XO
                         OX

          A "potential cutting stone" is adjacent to two enemy strings
          which do share a liberty. For example, X in:


                         XO
                         O.

          For cutting strings we set `worm[].cutstone=2'. For potential
          cutting strings we set `worm[].cutstone=1'.

   * `cutstone2'

          Cutting points are identified by the patterns in the
          connections database. Proper cuts are handled by the fact
          that attacking and defending moves also count as moves
          cutting or connecting the surrounding dragons.  The
          `cutstone2' field is set during `find_cuts()', called from
          `make_domains()'.

   * `genus'

          There are two separate notions of "genus" for worms and
          dragons. The dragon notion is more important, so
          `dragon[pos].genus' is a far more useful field than
          `worm[pos].genus'. Both fields are intended as approximations
          to the number of eyes. The "genus" of a string is the number
          of connected components of its complement, minus one. It is
          an approximation to the number of eyes of the string.

   * `inessential'

          An "inessential" string is one which meets a criterion
          designed to guarantee that it has no life potential unless a
          particular surrounding string of the opposite color can be
          killed. More precisely an "inessential string" is a string S
          of genus zero, not adjacent to any opponent string which can
          be easily captured, and which has no edge liberties or second
          order liberties, and which satisfies the following further
          property: If the string is removed from the board, then the
          remaining cavity only borders worms of the opposite color.


   * `invincible'

          An "invincible" worm is one which GNU Go thinks cannot be
          captured. Invincible worms are computed by the function
          `unconditional_life()' which tries to find those worms of the
          given color that can never be captured, even if the opponent
          is allowed an arbitrary number of consecutive moves.

   * unconditional_status

          Unconditional status is also set by the function
          `unconditional_life'. This is set ALIVE for stones which are
          invincible. Stones which can not be turned invincible even if
          the defender is allowed an arbitrary number of consecutive
          moves are given an unconditional status of DEAD. Empty points
          where the opponent cannot form an invincible worm are called
          unconditional territory. The unconditional status is set to
          `WHITE_BORDER' or `BLACK_BORDER' depending on who owns the
          territory. Finally, if a stone can be captured but is
          adjacent to unconditional territory of its own color, it is
          also given the unconditional status `ALIVE'. In all other
          cases the unconditional status is `UNKNOWN'.

          To make sense of these definitions it is important to notice
          that any stone which is alive in the ordinary sense (even if
          only in seki) can be transformed into an invincible group by
          some number of consecutive moves. Well, this is not entirely
          true because there is a rare class of seki groups not
          satisfying this condition. Exactly which these are is left as
          an exercise for the reader. Currently `unconditional_life',
          which strictly follows the definitions above, calls such seki
          groups unconditionally dead, which of course is a misfeature.
          It is possible to avoid this problem by making the algorithm
          slightly more complex, but this is left for a later revision.

   * `int attack_points[MAX_TACTICAL_POINTS]'

   * `attack_codes[MAX_TACTICAL_POINTS]'

   * `int defense_points[MAX_TACTICAL_POINTS];'

   * `int defend_codes[MAX_TACTICAL_POINTS];'

          If the tactical reading code (*note Tactical Reading::) finds
          that the worm can be attacked, `attack_points[0]' is a point
          of attack, and `attack_codes[0]' is the attack code, `WIN',
          `KO_A' or `KO_B'. If multiple attacks are known,
          `attack_points[k]' and `attack_codes[k]' are used. Similarly
          with the defense codes and defense points.

   * `int attack_threat_points[MAX_TACTICAL_POINTS];'

   * `int attack_threat_codes[MAX_TACTICAL_POINTS];'

   * `int defense_threat_points[MAX_TACTICAL_POINTS];'

   * `int defense_threat_codes[MAX_TACTICAL_POINTS];'

          These are points that threaten to attack or defend a worm.

   The function `makeworms()' will generate data for all worms.


File: gnugo.info,  Node: Amalgamation,  Next: Connection,  Prev: Worms,  Up: Worms and Dragons

Amalgamation
============

   A dragon, we have said, is a group of stones which are treated as a
unit. It is a working hypothesis that these stones will live or die
together. Thus the program will not expect to disconnect an opponent's
strings if they have been amalgamated into a single dragon.

   The function `make_dragons()' will amalgamate worms into dragons by
maintaining separate arrays `worm[]' and `dragon[]' containing similar
data. Each dragon is a union of worms. Just as the data maintained in
`worm[]' is constant on each worm, the data in `dragon[]' is constant
on each dragon.

   Amalgamation of worms in GNU Go 3.0 proceeds as follows.  First we
amalgamate all boundary components of an eyeshape. Thus in the
following example:


     .OOOO.       The four X strings are amalgamated into a
     OOXXO.       single dragon because they are the boundary
     OX..XO       components of a blackbordered cave. The
     OX..XO       cave could contain an inessential string
     OOXXO.       with no effect on this amalgamation.
     XXX...

   The code for this type of amalgamation is in the routine
`dragon_eye()', discussed further in EYES.

   Next, we amalgamate strings which seem uncuttable. We amalgamate
dragons which either share two or more common liberties, or share one
liberty into the which the opponent cannot play without being captured.
(ignores ko rule).


        X.    X.X     XXXX.XXX         X.O
        .X    X.X     X......X         X.X
                      XXXXXX.X         OXX

   A database of connection patterns may be found in `patterns/conn.db'.


File: gnugo.info,  Node: Connection,  Next: Half Eyes,  Prev: Amalgamation,  Up: Worms and Dragons

Connection
==========

   The fields `black_eye.cut' and `white_eye.cut' are set where the
opponent can cut, and this is done by the B (break) class patterns in
`conn.db'.  There are two important uses for this field, which can be
accessed by the autohelper functions `xcut()' and `ocut()'. The first
use is to stop amalgamation in positions like


     ..X..
     OO*OO
     X.O.X
     ..O..

where X can play at * to cut off either branch. What happens here is
that first connection pattern CB1 finds the double cut and marks * as a
cutting point. Later the C (connection) class patterns in conn.db are
searched to find secure connections over which to amalgamate dragons.
Normally a diagonal connection would be deemed secure and amalgamated
by connection pattern CC101, but there is a constraint requiring that
neither of the empty intersections is a cutting point.

   A weakness with this scheme is that X can only cut one connection,
not both, so we should be allowed to amalgamate over one of the
connections.  This is performed by connection pattern CC401, which with
the help of `amalgamate_most_valuable_helper()' decides which
connection to prefer.

   The other use is to simplify making alternative connection patterns
to the solid connection. Positions where the diag_miai helper thinks a
connection is necessary are marked as cutting points by connection
pattern 12. Thus we can write a connection pattern like `CC6':


     ?xxx?     straight extension to connect
     XOO*?
     O...?
     
     :8,C,NULL
     
     ?xxx?
     XOOb?
     Oa..?
     
     ;xcut(a) && odefend_against(b,a)

where we verify that a move at `*' would stop the enemy from safely
playing at the cutting point, thus defending against the cut.


File: gnugo.info,  Node: Half Eyes,  Next: Dragons,  Prev: Connection,  Up: Worms and Dragons

Half Eyes and False Eyes
========================

   A "half eye" is a place where, if the defender plays first, an eye
will materialize, but where if the attacker plays first, no eye will
materialize. A "false eye" is a vertex which is surrounded by a dragon
yet is not an eye. Here is a half eye:


     XXXXX
     OO..X
     O.O.X
     OOXXX

   Here is a false eye:


     XXXXX
     XOO.X
     O.O.X
     OOXXX

   The "topological" algorithm for determining half and false eyes is
described elsewhere (*note Eye Topology::).

   The half eye data is collected in the dragon array. Before this is
done, however, an auxiliary array called half_eye_data is filled with
information. The field `type' is 0, or else `HALF_EYE' or `FALSE_EYE'
depending on which type is found; the fields `attack_point[]' point to
up to 4 points to attack the half eye, and similarly `defense_point[]'
gives points to defend the half eye.


     struct half_eye_data half_eye[MAX_BOARD];
     
     struct half_eye_data {
       float value;          /* Topological eye value */
       int type;             /* HALF_EYE or FALSE_EYE */
       int num_attacks;      /* Number of attacking points */
       int attack_point[4];  /* The moves to attack a topological halfeye */
       int num_defends;      /* Number of defending points */
       int defense_point[4]; /* The moves to defend a topological halfeye */
     };

   The array `struct half_eye_data half_eye[MAX_BOARD]' contains
information about half and false eyes.  If the type is `HALF_EYE' then
up to four moves are recorded which can either attack or defend the
eye. In rare cases the attack points could be different from the
defense points.

