This is gnugo.info, produced by makeinfo version 4.2 from gnugo.texi.

INFO-DIR-SECTION GNU games
START-INFO-DIR-ENTRY
* GNU go: (gnugo).          The GNU Go program
END-INFO-DIR-ENTRY


File: gnugo.info,  Node: Invoking GNU Go,  Prev: SGF Support,  Up: User Guide

Invoking GNU Go: Command line options
=====================================

Some basic options
------------------

   * `--help', `-h'

          Print a help message describing the options. This will also
          tell you the defaults of various parameters, most importantly
          the level and cache size. The default values of these
          parameters can be set before compiling by `configure'.  If
          you forget the defaults you can find out using `--help'.

   * `--boardsize SIZE'

          Set the board size

   * `--komi NUM'

          Set the komi

   * `--level LEVEL'

          GNU Go can play with different strengths and speeds. Level 10
          is the default. Decreasing the level will make GNU Go faster
          but less accurate in its reading.

   * `--quiet', `--silent'

          Don't print copyright and other messages. Messages
          specifically requested by other command line options, such as
          `--trace', are not supressed.

   * `-l', `--infile FILENAME'

          Load the named SGF file. GNU Go will generate a move for the
          player who is about to move. If you want to override this and
          generate a move for the other player you may add the option
          `--color <COLOR>' where <COLOR> is `black' or `white'.

   * `-L', `--until MOVE'

          Stop loading just before the indicated move is played. MOVE
          can be either the move number or location.

   * `-o', `--outfile FILENAME'

          Write sgf output to file

   * `-O', `--output-flags FLAGS'

          Add useful information to the sgf file. Flags can be 'd', 'v'
          or both (i.e. 'dv'). If 'd' is specified, dead and critical
          dragons are marked in the sgf file. If 'v' is specified, move
          valuations around the board are indicated.

   * `--mode MODE'

          Force the playing mode ('ascii', 'emacs,' 'gmp' or 'gtp').
          The default is ASCII, but if no terminal is detected GMP (Go
          Modem Protocol) will be assumed. In practice this is usually
          what you want, so you may never need this option.

   * `--resign-allowed'

          GNU Go will resign games if this option is enabled.
          Unfortunately the Go Modem Protocol has no provision for
          passing a resignation, so this option has no effect in GMP
          mode.

   * `--never-resign'

          GNU Go will not resign games. This is the default unless you
          build the engine with the configure option
          `--enable-resignation-allowed'.

Other general options
---------------------

   * `-M', `--cache-size MEGS'

          Memory in megabytes used for caching of read results. The
          default size is 8 unless you configure gnugo with the command
          `configure --enable-cache-size=SIZE' before compiling to make
          SIZE the default (*note Installation::). GNU Go stores
          results of its reading calculations in a Hash table (*note
          Hashing::). If the Hash table is filled, it is emptied and
          the reading continues, but some reading may have to be
          repeated that was done earlier, so a larger cache size will
          make GNU Go run faster, provided the cache is not so large
          that swapping occurs. Swapping may be detected on GNU/Linux
          machines using the program `top'. However, if you have ample
          memory or if performance seems to be a problem you may want
          to increase the size of the cache using this option.

   * `--chinese-rules'

          Use Chinese rules. This means that the Chinese or Area
          Counting is followed. It may affect the score of the game by
          one point in even games, more if there is a handicap (since
          in Chinese Counting the handicap stones count for Black) or
          if either player passes during the game.

   * `--japanese-rules'

          Use Japanese Rules. This is the default unless you specify
          `--enable-chinese-rules' as a configure option.

   * `--copyright': Display the copyright notice

   * `--version' or `-v': Print the version number

   * `--printsgf FILENAME':

          Create an SGF file containing a diagram of the board. Useful
          with `-l' and `-L' to create a diagram of the board from
          another sgf file. Illegal moves are indicated with the private
          `IL' property.  This property is not used in the FF4 SGF
          specification, so we are free to preempt it. This feature is
          used in the CGI interface in `interface/html/gg.cgi'.

   * `--options'

          Print which experimental configure options were compiled into
          the program (*note Experimental Options::).

   * `--orientation N'

          Combine with `-l'. The Go board can be oriented in 8 different
          ways, counting reflections and rotations of the position;
          this option selects an orientation (default 0). The parameter
          `n' is an integer between 0 and 7.

Other options affecting strength and speed
------------------------------------------

   * `--level AMOUNT'

          The higher the level, the deeper GNU Go reads. Level 10 is
          the default.  If GNU Go plays too slowly on your machine, you
          may want to decrease it.

   This single parameter `--level' is the best way of choosing whether
to play stronger or faster. It controls a host of other parameters
which may themselves be set individually at the command line.  The
default values of these parameters may be found by running `gnugo
--help'.

   Unless you are working on the program you probably don't need these
options. Instead, just adjust the single variable `--level'. The
remaining options are of use to developers tuning the program for
performance and accuracy. For completeness, here they are.

   * `-D', `--depth DEPTH'

          Deep reading cutoff. When reading beyond this depth (default
          16) GNU Go assumes that any string which can obtain 3
          liberties is alive. Thus GNU Go can read ladders to an
          arbitrary depth, but will miss other types of capturing moves.

   * `-B', `--backfill-depth DEPTH'

          Deep reading cutoff. Beyond this depth (default 12) GNU Go
          will no longer try backfilling moves in its reading.

   * `--backfill2-depth DEPTH'

          Another depth controlling how deeply GNU Go looks for
          backfilling moves. The moves tried below `backfill2_depth'
          are generally more obscure and time intensive than those
          controlled by `backfill_depth', so this parameter has a lower
          default.

   * `-F', `--fourlib-depth DEPTH'

          Deep reading cutoff. When reading beyond this depth (default
          7) GNU Go assumes that any string which can obtain 4
          liberties is alive.

   * `-K', `--ko-depth DEPTH'

          Deep reading cutoff. Beyond this depth (default 8) GNU Go no
          longer tries very hard to analyze kos.

   * `--branch-depth DEPTH'

          This sets the `branch_depth', typically a little below the
          `depth'. Between `branch_depth' and `depth', attacks on
          strings with 3 liberties are considered but branching is
          inhibited, so fewer variations are considered.  Below this
          depth (default 13), GNU Go still tries to attack strings with
          only 3 liberties, but only tries one move at each node.

   * `--break_chain-cutoff DEPTH'

          Set the `break_chain_depth'. Beyond this depth, GNU Go
          abandons some attempts to defend groups by trying to capture
          part of the surrounding chain.

   * `--aa-depth DEPTH'

          The reading function `atari_atari' looks for combinations
          beginning with a series of ataris, and culminating with some
          string having an unexpected change in status (e.g. alive to
          dead or critical). This command line optio sets the parameter
          `aa_depth' which determines how deeply this function looks
          for combinations.

   * `--superstring-depth'

          A superstring (*note Superstrings::) is an amalgamation of
          tightly strings. Sometimes the best way to attack or defend a
          string is by attacking or defending an element of the
          superstring.  Such tactics are tried below
          `superstring_depth' and this command line option allows this
          parameter to be set.

   The preceeding options are documented with the reading code (*note
Reading Basics::).

   * `--owl-branch' Below this depth Owl only considers one move.
     Default 8.

   * `--owl-reading' Below this depth Owl assumes the dragon has
     escaped.  Default 20.

   * `--owl-node-limit'

          If the number of variations exceeds this limit, Owl assumes
          the dragon can make life. Default 1000. We caution the user
          that increasing `owl_node_limit' does not necessarily
          increase the strength of the program.

   * `--owl-node-limit N'

          If the number of variations exceeds this limit, Owl assumes
          the dragon can make life. Default 1000.  We caution the user
          that increasing `owl_node_limit' does not necessarily
          increase the strength of the program.

   * `--owl-distrust N'

          Below this limit some owl reading is truncated.

Ascii mode options
------------------

   * `--color COLOR'

          Choose your color ('black' or 'white').

   * `--handicap NUMBER'

          Choose the number of handicap stones (0-9)

Development options
-------------------

   * `--replay COLOR'

          Replay all moves in a game for either or both colors. If used
          with the `-o' option the game record is annotated with move
          values. This option requires `-l FILENAME'. The color can be:
             * white: replay white moves only

             * black: replay black moves only

             * both: replay all moves
          When the move found by genmove differs from the move in the
          sgf file the values of both moves are reported thus:

               Move 13 (white): GNU Go plays C6 (20.60) - Game move F4 (20.60)

          This option is useful if one wants to confirm that a change
          such as a speedup or other optimization has not affected the
          behavior of the engine. Note that when several moves have the
          same top value (or nearly equal) the move generated is not
          deterministic (though it can be made deterministic by
          starting with the same random seed). Thus a few deviations
          from the move in the sgf file are to be expected. Only if the
          two reported values differ should we conclude that the engine
          plays differently from the engine which generated the sgf
          file.  *Note Regression::.

   * `-a', `--allpats'

          Test all patterns, even those smaller in value than the
          largest move found so far. This should never affect GNU Go's
          final move, and it will make it run slower. However this can
          be very useful when "tuning" GNU Go. It causes both the
          traces and the output file (`-o') to be more informative.

   * `-T', `--printboard': colored display of dragons.

          Use rxvt, xterm or Linux Console. (*note Colored Display::)

   * `--showtime'

          Print timing information to stderr.

   * `-E', `--printeyes': colored display of eye spaces

          Use rxvt, xterm or Linux Console. (*note Colored Display::)

   * `-d', `--debug LEVEL'

          Produce debugging output. The debug level is given in
          hexadecimal, using the bits defined in the following table
          from `engine/gnugo.h'. A list of these may be produced using
          `--debug-flags'. Here they are in hexadecimal:

                 DEBUG_INFLUENCE             0x0001
                 DEBUG_EYES                  0x0002
                 DEBUG_OWL                   0x0004
                 DEBUG_ESCAPE                0x0008
                 DEBUG_MATCHER               0x0010
                 DEBUG_DRAGONS               0x0020
                 DEBUG_SEMEAI                0x0040
                 DEBUG_LOADSGF               0x0080
                 DEBUG_HELPER                0x0100
                 DEBUG_READING               0x0200
                 DEBUG_WORMS                 0x0400
                 DEBUG_MOVE_REASONS          0x0800
                 DEBUG_OWL_PERFORMANCE       0x1000
                 DEBUG_LIFE                  0x2000
                 DEBUG_FILLLIB               0x4000
                 DEBUG_READING_PERFORMANCE   0x8000
                 DEBUG_SCORING               0x010000
                 DEBUG_AFTERMATH             0x020000
                 DEBUG_ATARI_ATARI           0x040000
                 DEBUG_READING_CACHE         0x080000
                 DEBUG_TERRITORY             0x100000
                 DEBUG_OWL_PERSISTENT_CACHE  0X200000
                 DEBUG_TOP_MOVES             0x400000
                 DEBUG_MISCELLANEOUS         0x800000
                 DEBUG_ORACLE_STREAM         0x1000000

          These debug flags are additive. If you want to turn on both
          dragon and worm debugging you can use `-d0x420'.

   * `--debug-flags'

          Print the list of debug flags

   * `-H', `--hash LEVEL'

          hash (see `engine/gnugo.h' for bits).

   * `-w', `--worms'

          Print more information about worm data.

   * `-m', `--moyo LEVEL'

          moyo debugging, show moyo board. The LEVEL is fully
          documented elsewhere (*note Influential Display::).

   * `-b', `--benchmark NUMBER'

          benchmarking mode - can be used with `-l'. Causes GNU Go to
          play itself repeatedly, seeding the start of the game with a
          few random moves. This method of testing the program is
          largely superceded by use of the `twogtp' program.

   * `-S', `--statistics'

          Print statistics (for debugging purposes).

   * `-t', `--trace'

          Print debugging information. Use twice for more detail.

   * `-r', `--seed SEED'

          Set random number seed. This can be used to guarantee that
          GNU Go will make the same decisions on multiple runs through
          the same game. If `seed' is zero, GNU Go will play a
          different game each time.

   * `--decide-string LOCATION'

          Invoke the tactical reading code (*note Tactical Reading:: to
          decide whether the string at LOCATION can be captured, and if
          so, whether it can be defended. If used with `-o', this will
          produce a variation tree in SGF.

   * `--decide-owl LOCATION'

          Invoke the owl code (*note The Owl Code::) to decide whether
          the dragon at LOCATION can be captured, and whether it can be
          defended. If used with `-o', this will produce a variation
          tree in SGF.

   * `--decide-connection LOCATION1/LOCATION2'

          Decide whether dragons at LOCATION1 and LOCATION2 can be
          connected.  Useful in connection with `-o' to write the
          variations to an SGF file.

   * `--decide-dragon-data LOCATION'

          Print complete information about the status of the dragon at
          LOCATION.

   * `--decide-semeai LOCATION1/LOCATION2'

          At LOCATION1 and LOCATION2 are adjacent dragons of the
          opposite color. Neither is aliveby itself, and their fate
          (alive, dead or seki) depends on the outcome of a semeai
          (capturing race).  Decide what happens.  Useful in connection
          with `-o' to write the variations to an SGF file.

   * `--decide-tactical-semeai LOCATION1/LOCATION2'

          Similar to `--decide-semeai', except that moves proposed by
          the owl code are not considered.

   * `--decide-position'

          Try to attack and defend every dragon with dragon.escape<6. If
          used with `-o', writes the variations to an sgf file.

   * `--decide-eye LOCATION'

          Evaluates the eyespace at LOCATION and prints a report. You
          can get more information by adding `-d0x02' to the command
          line.  (*note Eye Local Game Values::.)

   * `--decide-surrounded LOCATION'

          A dragon is _surrounded_ if it is contained in the convex
          hull of its unfriendly neighbor dragons. This does not mean
          that it cannot escape, but it is often a good indicator that
          the dragon is under attack. This option draws the convex hull
          of the neighbor dragons and decides whether the dragon at
          LOCATION is surrounded.

   * `--decide-combination'

          Calls the function `atari_atari' to decide whether there
          exist combinations on the board.

   * `--score METHOD'

          Requires `-l' to specify which game to score and `-L' if you
          want to score anywhere else than at the end of the game
          record.  METHOD can be "estimate", "finish", or "aftermath".
          "finish" and "aftermath" are appropriate when the game is
          complete, or nearly so, and both try to supply an accurate
          final score. Notice that if the game is not already finished
          it will be played out, which may take quite a long time if
          the game is far from complete. The "estimate" method may be
          used to get a quick estimate during the middle of the game.
          Any of these options may be combined with `--chinese-rules'
          if you want to use Chinese (Area) counting.

          If the option `-o OUTPUTFILENAME' is provided, the result
          will also be written as a comment in the output file. For the
          "finish" and "aftermath" scoring algorithms, the selfplayed
          moves completing the game are also stored.

             * estimate

                    Examine the status of all groups on the board, then
                    give a quick estimate of the score using the Bouzy
                    5/21 algorithm (*note Alternative Moyo::).

             * finish

                    Finish the game by selfplaying until two passes,
                    then determine the status of all stones and
                    estimate territory using the Bouzy 5/21 algorithm
                    (*note Alternative Moyo::).

             * aftermath

                    Finish the game by selfplaying until two passes,
                    then accurately determine status of all stones by
                    playing out the "aftermath", i.e.  playing on until
                    all stones except ones involved in seki have become
                    either unconditionally (in the strongest sense)
                    alive or unconditionally dead (or captured). Slower
                    than `--score finish', and while these algorithms
                    usually agree, if they differ, `--score aftermath'
                    is most likely to be correct.

   * `--score aftermath --capture-all-dead --chinese-rules'

          This combination mandates *Tromp-Taylor* scoring. The
          Tromp-Taylor ruleset requires the game to be played out until
          all dead stones are removed, then uses area (Chinese) scoring.
          The option `--capture-all-dead' requires the aftermath code
          to finish capturing all dead stones.

Experimental options
--------------------

   Most of these are available as configure options and are described
in *Note Experimental Options::.

   * `--options'

          Print which experimental configure options were compiled into
          the program.

   * `--with-break-in'

   * `--without-break-in'

          Use or do not use the experimental break-in code. This option
          has no effect at level 9 or below. The break in code is
          enabled by default at level 10, and the only difference
          between levels 9 and level 10 is that the break in code is
          disabled at level 9.

   * `--nofusekidb'

          Turn off the fuseki database.

   * `--nofuseki'

          Turn off fuseki moves entirely

   * `--nojosekidb'

          Turn off the joseki database.

   * `--mirror'

          Try to play mirror go.

   * `--mirror-limit N'

          Stop mirroring when N stones are on the board.


File: gnugo.info,  Node: Overview,  Next: Analyzing,  Prev: User Guide,  Up: Top

GNU Go engine overview
**********************

   This chapter is an overview of the GNU Go internals. Further
documentation of how any one module or routine works may be found in
later chapters or comments in the source files.

   GNU Go starts by trying to understand the current board position as
good as possible. Using the information found in this first phase, and
using additional move generators, a list of candidate moves is
generated.  Finally, each of the candidate moves is valued according to
its territorial value (including captures or life-and-death effects),
and possible strategical effects (such as strengthening a weak group).

   Note that while GNU Go does, of course, do a lot of reading to
analyze possible captures, life and death of groups etc., it does not
(yet?) have a fullboard lookahead.

* Menu:

* Examining the Position::		Gathering Information
* Move Generators::			Selecting Candidate Moves
* Move Valuation::			Selecting the best Move
* Detailed Sequence of Events::		Outline of `genmove()'.
* Roadmap::				Description of the different files.
* Coding Styles::			Coding conventions.
* Navigating the Source::		Navigating the Source.


File: gnugo.info,  Node: Examining the Position,  Next: Move Generators,  Up: Overview

Gathering Information
=====================

   This is by far the most important phase in the move generation.
Misunderstanding life-and-death situations can cause gross mistakes.
Wrong territory estimates will lead to inaccurate move valuations.  Bad
judgement of weaknesses of groups make strategic mistakes likely.

   This information gathering is done by the function
`examine_position()'.  It first calls `make_worms()'.

   Its first steps are very simple: It identifies sets of directly
connected stones-we call them "worms"-, and notes their sizes and their
number of liberties.

   Soon after comes the most important step of the worm analysis: The
tactical reading code (*note Tactical Reading::) is called for every
worm. It tries to read out which worms can be captured directly, giving
up as soon as a worm can reach 5 liberties. If a worm can be captured,
the engine of course looks for moves defending against this capture.
Also, a lot of effort is made to find virtually all moves that achieve
the capture or defense of a worm.

   After knowing which worms are tactically stable, we can make a first
picture of the balance of power across the board: The *Note Influence::
code is called for the first time.

   This is to aid the next step, the analysis of dragons. By a "dragon"
we mean a group of stones that cannot be disconnected.

   Naturally the first step in the responsible function `make_dragons()'
is to identify these dragons, i.e. determine which worms cannot be
disconnected from each other. This is partly done by patterns, but in
most cases the specialized readconnect code is called. This module does
a minimax search to determine whether two given worms can be connected
with, resp. disconnected from each other.

   Then we compute various measures to determine how strong or weak any
given dragon is:
   * A crude estimate of the number of eyes is made.

   * The results of the influence computations is used to see which
     dragons are adjacent to own territory or a moyo.

   * A guess is made for the potential to escape if the dragon got
     under attack.

   For those dragons that are considered weak, a life and death analysis
is made (*note The Owl Code::). If two dragons next to each other are
found that are both not alive, we try to resolve this situation with
the semeai module.

   For a more detailed reference of the worm and dragon analysis (and
explanations of the data structures used to store the information), see
*Note Worms and Dragons::.

   The influence code is then called second time to make a detailed
analysis of likely territory. Of course, the life-and-death status' of
dragons are now taken into account.

   The territorial results of the influence module get corrected by the
break-in module. This specifically tries to analyze where an opponent
could break into an alleged territory, with sequences that would be too
difficult to see for the influence code.


File: gnugo.info,  Node: Move Generators,  Next: Move Valuation,  Prev: Examining the Position,  Up: Overview

Move Generators
===============

   Once we have found out all about the position it is time to generate
the best move. Moves are proposed by a number of different modules
called "move generators". The move generators themselves do not set the
values of the moves, but enumerate justifications for them, called
"move reasons". The valuation of the moves comes last, after all moves
and their reasons have been generated.

   For a list and explanation of move reasons used in GNU Go, and how
they are evaluated, see *Note Move Generation::.

   There are a couple of move generators that only extract data found in
the previous phase, examining the position:

   * `worm_reasons()'

          Moves that have been found to capture or defend a worm are
          proposed as candidates.

   * `owl_reasons()'

          The status of every dragon, as it has been determined by the
          owl code (*note The Owl Code::) in the previous phase, is
          reviewed. If the status is critical, the killing or defending
          move gets a corresponding move reason.

   * `semeai_move_reasons()'

          Similarly as `owl_reasons', this function proposes moves
          relevant for semeais.

   * `break_in_move_reasons()'

          This suggests moves that have been found to break into
          opponent's territory by the break-in module.

   The following move generators do additional work:

   * `fuseki()'

          Generate a move in the early fuseki, either in an empty
          corner of from the fuseki database.

   * `shapes()'

          This is probably the most important move generator.  It finds
          patterns from `patterns/patterns.db',
          `patterns/patterns2.db', `patterns/fuseki.db', and the joseki
          files in the current position.  Each pattern is matched in
          each of the 8 possible orientations obtainable by rotation and
          reflection. If the pattern matches, a so called "constraint"
          may be tested which makes use of reading to determine if the
          pattern should be used in the current situation.  Such
          constraints can make demands on number of liberties of
          strings, life and death status, and reading out ladders, etc.
          The patterns may call helper functions, which may be hand
          coded (in `patterns/helpers.c') or autogenerated.

          The patterns can be of a number of different classes with
          different goals.  There are e.g. patterns which try to attack
          or defend groups, patterns which try to connect or cut
          groups, and patterns which simply try to make good shape. (In
          addition to the large pattern database called by `shapes()',
          pattern matching is used by other modules for different tasks
          throughout the program. *Note Patterns::, for a complete
          documentation of patterns.)

   * `combinations()'

          See if there are any combination threats or atari sequences
          and either propose them or defend against them.

   * `revise_thrashing_dragon()'

          This module does not directly propose move: If we are clearly
          ahead, and the last move played by the opponent is part of a
          dead dragon, we want to attack that dragon again to be on the
          safe side. This is done be setting the status of this
          "thrashing dragon" to unkown and repeating the shape move
          generation and move valution.

   * `endgame_shapes()'

          If no move is found with a value greater than 6.0, this
          module matches a set of extra patterns which are designed for
          the endgame.  The endgame patterns can be found in
          `patterns/endgame.db'.

   * `revise_semeai()'

          If no move is found, this module changes the status of
          opponent groups involved in a semeai from `DEAD' to
          `UNKNOWN'.  After this, genmove runs `shapes' and
          `endgame_shapes' again to see if a new move turns up.

   * `fill_liberty()'

          Fill a common liberty. This is only used at the end of the
          game. If necessary a backfilling or backcapturing move is
          generated.


File: gnugo.info,  Node: Move Valuation,  Next: Detailed Sequence of Events,  Prev: Move Generators,  Up: Overview

Move Valuation
==============

   After the move generation modules have run, each proposed candidate
move goes through a detailed valuation by the function
`review_move_reasons'. This invokes some analysis to try to turn up
other move reasons that may have been missed.

   The most important value of a move is its territorial effect.  *note
Influence and Territory:: explains in detail how this is determined.

   This value is modified for all move reasons that cannot be expressed
directly in terms of territory, such as combination attacks (where it
is not clear which of several strings will get captured), strategical
effects, connection moves, etc.  A large set heuristics is necessary
here, e.g. to avoid duplication of such values. This is explained in
more detail in *Note Valuation::.


File: gnugo.info,  Node: Detailed Sequence of Events,  Next: Roadmap,  Prev: Move Valuation,  Up: Overview

Detailed Sequence of Events
===========================

   First comes the sequence of events when `examine_position()' is run
from `genmove()'. This is for reference only.

purge persistent reading cache (*note Persistent Cache::)
`make_worms()' (*note Worms::):
  `build_worms()' finds and identifies the worms
  compute effective size of each worm
  `unconditional_life()'
  `find_worm_attacks_and_defenses()':
    for each attackable worm:
      set `worm.attack'
      `add_attack_move()'
    `find_attack_patterns()' to find a few more attacks
    for each defensible worm
      set `worm.defend'
      `add_defense_move'
      if point of attack is not adjacent to worm see if it defends
    `find_defense_patterns()' to find a few more defenses
    for each attackable worm try each liberty
      if it attacks `add_attack_move'
      if it defends `add_defense_move'
  find kos.
  for each worm
    find higher order liberties
  find cutting points (worm.cutstone)
  for each worm compute the genus (*note Worms::)
  try to improve values of worm.attack and worm.defend
  try to repair situations where adjacent worms can be
    both attacked and defended
  find worm lunches
  find worm threats
`compute_initial_influence()' (*note Influence::)
  `compute_influence()'
    `find_influence_patterns()'
  at each intersection `accumulate_influence()'
  `segment_influence()'
`make_dragons()' (*note Dragons::)
  initialize dragon data
  find the inessential worms
  `make_domains()'
    initialize eye data
    `compute_primary_domains()'
    fill out arrays black_eye and white_eye
      describing eyeshapes
    find_cuts()
    for every eyespace
      `originate_eye()'
    count_neighbors()
  `find_connections()'
  amalgamate dragons sharing an eyespace
  `initialize_supplementary_dragon_data()'
  find adjacent worms which can be captured (dragon lunches)
  find topological half eyes and false eyes
  `modify_eye_spaces()'
  for each eye space
    `compute_eyes()'
    store the results in black_eye, white_eye arrays
  compute the genus of each dragon
  for each dragon
    `compute_escape()'
  `resegment_initial_influence()'
  for each dragon
    `influence_get_moyo_size()'
  for each dragon
     `compute_dragon_status()'
  `find_neighbor_dragons()'
  `purge_persistent_owl_cache()'
  for each dragon which seems surrounded
     try `owl_attack()' and `owl_defend()'
     if appropriate find owl threats
  for each dragon
     set dragon.matcher_status
  for each dragon
     set dragon2.safety
  `semeai()'
  revise opinion of which worms are inessential
  count non-dead dragons of each color
`owl_reasons()' (*note The Owl Code::)
`compute_initial_influence()' again (*note Influence::)

   Now a summary of the sequence of events during the move generation
and selection phases of `genmove()', which take place after the
information gathering phase has been completed:

`fuseki()'
`shapes()'
`review_move_reasons()'
  `find_more_attack_and_defense_moves()'
  `remove_opponent_attack_and_defense_moves()'
  `do_remove_false_attack_and_defense_moves()'
  `examine_move_safety()'
  `induce_secondary_move_reasons()'
  `value_moves()'
  find the ten best moves
if the value of the best move is < 6.0
  `endgame_shapes()'
if no move found yet
  `revise_semeai()'
  `shapes()'
  `endgame_shapes()'
if still no move found
  `fill_liberty()'
if still no move found
    pass


File: gnugo.info,  Node: Roadmap,  Next: Coding Styles,  Prev: Detailed Sequence of Events,  Up: Overview

Roadmap
=======

   The GNU Go engine is contained in two directories, `engine/' and
`patterns/'. Code related to the user interface, reading and writing of
smart go format files, and testing are found in the directories
`interface/', `sgf/', and `regression/'. Code borrowed from other GNU
programs is contained in `utils/'. That directory also includes some
code developed within GNU Go which is not go specific. Documentation is
in `doc/'.

   In this document we will describe some of the individual files
comprising the engine code in `engine/' and `patterns/'. In `interface/'
we mention two files:

   * `gmp.c'

          This is the Go Modem Protocol interface (courtesy of William
          Shubert and others). This takes care of all the details of
          exchanging setup and moves with Cgoban, or any other driving
          program recognizing the Go Modem Protocol.

   * `main.c'

          This contains `main()'. The `gnugo' target is thus built in
          the `interface/' directory.

Files in `engine/'
------------------

   In `engine/' there are the following files:

   * `aftermath.c'

          Contains algorithms which may be called at the end of the
          game to generate moves that will generate moves to settle the
          position, if necessary playing out a position to determine
          exactly the status of every group on the board, which GNU Go
          can get wrong, particularly if there is a seki. This module is
          the basis for the most accurate scoring algorithm available
          in GNU Go.

   * `board.c'

          This file contains code for the maintenance of the board.
          For example it contains the important function `trymove()'
          which tries a move on the board, and `popgo()' which removes
          it by popping the move stack. At the same time vital
          information such as the number of liberties for each string
          and their location is updated incrementally.

   * `clock.c'

          Clock code, including code allowing GNU Go to automatically
          adjust its level in order to avoid losing on time in
          tournaments.

   * `dragon.c'

          This contains `make_dragons()'. This function is executed
          before the move-generating modules `shapes()' `semeai()' and
          the other move generators but after `make_worms'. It tries to
          connect worms into dragons and collect important information
          about them, such as how many liberties each has, whether (in
          GNU Go's opinion) the dragon can be captured, if it lives,
          etc.

   * `fuseki.c'

          Generates fuseki (opening) moves from a database.

   * `filllib.c'

          Code to force filling of dame (backfilling if necessary) at
          the end of the game.

   * `genmove.c'

          This file contains `genmove()' and its supporting routines,
          particularly `examine_position()'.

   * `globals.c'

          This contains the principal global variables used by GNU Go.

   * `gnugo.h'

          This file contains declarations forming the public interface
          to the engine.

   * `hash.c' and `cache.c'

          Hashing code implementing Zobrist hashing. (*note Hashing::)
          The code in `hash.c' provides a way to hash board positions
          into compact descriptions which can be efficiently compared.
          The code in `cache.c' implements a kind of database for
          storing reading results, so they can be quickly retrieved.
          The caching code uses the board hashes as keys to the
          database.  They are split since these functionalities are
          sufficiently demarked that either file could be reimplemented
          without affecting the other one.  Note also that `matchpat()'
          uses the hashing code without also using the caching code.

   * `hash.h' and `cache.h'

          Header files for `hash.c' and `cache.c'.

   * `influence.c' and `influence.h'.

          This code determines which regions of the board are under the
          influence of either player.  (*note Influence::)

   * `liberty.h'

          Header file for the engine. The name "liberty" connotes
          freedom (*note Copying::).

   * `matchpat.c'

          This file contains the pattern matcher `matchpat()', which
          looks for patterns at a particular board location. The actual
          patterns are in the `patterns/' directory. The function
          `matchpat()' is called by every module which does pattern
          matching, notably `shapes'.

   * `move_reasons.c'

          This file contains the code which assigns values to every move
          after all the move reasons are gen

   * `optics.c'

          This file contains the code to recognize eye shapes,
          documented in *Note Eyes::.

   * `owl.c'

          This file does life and death reading. The paradigm is that
          moves are played by both players trying to expand and shrink
          the eyespace until a static configuration is reached where it
          can be analyzed by the code in `optics.c'.

   * `printutils.c'

          Print utilities

   * `reading.c'

          This file contains code to determine whether any given string
          can be attacked or defended. *Note Tactical Reading::, for
          details.

   * `score.c'

          Implements the Bouzy algorithms (*note Alternative Moyo::)
          and contains code for scoring the game.

   * `semeai.c'

          This file contains `semeai()', the module which tries to win
          capturing races. This module does not work particularly well
          and will eventually be replaced.

   * `shapes.c'

          This file contains `shapes()', the module called by
          `genmove()' which tries to find moves which match a pattern
          (*note Patterns::).

   * `showbord.c'

          This file contains `showboard()', which draws an ASCII
          representation of the board, depicting dragons (stones with
          same letter) and status (color). This was the primary
          interface in GNU Go 1.2, but is now a debugging aid.

   * `worm.c'

          This file contains `make_worms()', code which is run at the
          beginning of each move cycle, before the code in `dragon.c',
          to determine the attributes of every string. These attributes
          are things like liberties, wether the string can be captured
          (and how), etc

   * `utils.c'

          An assortment of utilities, described in greater detail below.

Files in `patterns/'
--------------------

   The directory `patterns/' contains files related to pattern matching.
Currently there are several types of patterns. A partial list:

   * move generation patterns in `patterns.db' and `patterns2.db'

   * move generation patterns in files `hoshi.db' etc. which are
     automatically build from the files `hoshi.sgf' etc. These comprise
     our small Joseki library.

   * patterns in `owl_attackpats.db', `owl_defendpats.db' and
     `owl_vital_apats.db'. These generate moves for the owl code (*note
     The Owl Code::).

   * Connection patterns in `conn.db' (*note Connections Database::)

   * Influence patterns in `influence.db' and `barriers.db' (*note
     Influence::)

   * eye patterns in `eyes.db' (*note Eyes::).

   The following list contains, in addition to distributed source files
some intermediate automatically generated files such as `patterns.c'.
These are C source files produced by "compiling" various pattern
databases, or in some cases (such as `hoshi.db') themselves
automatically generated pattern databases produced by "compiling"
joseki files in Smart Go Format.

   * `conn.db'

          Database of connection patterns.

   * `conn.c'

          Automatically generated file, containing connection patterns
          in form of struct arrays, compiled by `mkpat' from `conn.db'.

   * `eyes.c'

          Automatically generated file, containing eyeshape patterns in
          form of struct arrays, compiled by `mkpat' from `eyes.db'.

   * `eyes.h'

          Header file for `eyes.c'.

   * `eyes.db'

          Database of eyeshape patterns. *Note Eyes::, for details.

   * `helpers.c'

          These are helper functions to assist in evaluating moves by
          matchpat.

   * `hoshi.sgf'

          Smart Go Format file containing 4-4 point openings

   * `hoshi.db'

          Automatically generated database of 4-4 point opening
          patterns, make by compiling `hoshi.sgf'

   * `joseki.c'

          Joseki compiler, which takes a joseki file in Smart Go
          Format, and produces a pattern database.

   * `komoku.sgf'

          Smart Go Format file containing 3-4 point openings

   * `komoku.db'

          Automatically generated database of 3-4 point opening
          patterns, make by compiling `komoku.sgf'

   * `mkeyes.c'

          Pattern compiler for the eyeshape databases. This program
          takes `eyes.db' as input and produces `eyes.c' as output.

   * `mkpat.c'

          Pattern compiler for the move generation and connection
          databases. Takes the file `patterns.db' together with the
          autogenerated Joseki pattern files `hoshi.db', `komoku.db',
          `sansan.db', `mokuhadzushi.db', `takamoku.db' and produces
          `patterns.c', or takes `conn.db' and produces `conn.c'.

   * `mokuhazushi.sgf'

          Smart Go Format file containing 5-3 point openings

   * `mokuhazushi.db'

          Pattern database compiled from mokuhadzushi.sgf

   * `sansan.sgf'

          Smart Go Format file containing 3-3 point openings

   * `sansan.db'

          Pattern database compiled from `sansan.sgf'

   * `takamoku.sgf'

          Smart Go Format file containing 5-4 point openings

   * `takamoku.db'

          Pattern database compiled from takamoku.sgf.

   * `patterns.c'

          Pattern data, compiled from patterns.db by mkpat.

   * `patterns.h'

          Header file relating to the pattern databases.

   * `patterns.db' and `patterns2.db'

          These contain pattern databases in human readable form.



File: gnugo.info,  Node: Coding Styles,  Next: Navigating the Source,  Prev: Roadmap,  Up: Overview

Coding styles and conventions
=============================

Coding Conventions
------------------

   Please follow the coding conventions at:
<http://www.gnu.org/prep/standards_toc.html>

   Please preface every function with a brief description of its usage.

   Please help to keep this Texinfo documentation up-to-date.

Tracing
-------

   A function `gprintf()' is provided. It is a cut-down `printf',
supporting only `%c', `%d', `%s', and without field widths, etc. It
does, however, add some useful facilities:

   * `%m'

          Takes two parameters, and displays a formatted board
          co-ordinate.

   * indentation

          Trace messages are automatically indented to reflect the
          current stack depth, so it is clear during read-ahead when it
          puts a move down or takes one back.

   * "outdent"

          format string suppresses the indentation.

   Normally `gprintf()' is wrapped in one of the following:

   `TRACE(fmt, ...)':

     Print the message if the 'verbose' variable > 0.  (verbose is set
     by `-t' on the command line)

   `DEBUG(flags, fmt, ...)':

     While `TRACE' is intended to afford an overview of what GNU Go is
     considering, `DEBUG' allows occasional in depth study of a module,
     usually needed when something goes wrong. `flags' is one of the
     `DEBUG_*' symbols in `engine/gnugo.h'.  The `DEBUG' macro tests to
     see if that bit is set in the `debug' variable, and prints the
     message if it is.  The debug variable is set using the `-d'
     command-line option.

   The variable `verbose' controls the tracing. It can equal 0 (no
trace), 1, 2, 3 or 4 for increasing levels of tracing. You can set the
trace level at the command line by `-t' for `verbose=1', `-t -t' for
`verbose=2', etc. But in practice if you want more verbose tracing than
level 1 it is better to use gdb to reach the point where you want the
tracing; you will often find that the variable `verbose' has been
temporarily set to zero and you can use the gdb command `set var
verbose=1' to turn the tracing back on.

Assertions
----------

   Related to tracing are assertions. Developers are strongly encouraged
to pepper their code with assertions to ensure that data structures are
as they expect. For example, the helper functions make assertions about
the contents of the board in the vicinity of the move they are
evaluating.

   `ASSERT()' is a wrapper around the standard C `assert()' function.
In addition to the test, it takes an extra pair of parameters which are
the co-ordinates of a "relevant" board position. If an assertion fails,
the board position is included in the trace output, and `showboard()'
and `popgo()' are called to unwind and display the stack.

FIXME
-----

   We have adopted the convention of putting the word FIXME in comments
to denote known bugs, etc.


File: gnugo.info,  Node: Navigating the Source,  Prev: Coding Styles,  Up: Overview

Navigating the Source
=====================

   If you are using Emacs, you may find it fast and convenient to use
Emacs' built-in facility for navigating the source. Switch to the root
directory `gnugo-3.4.x/' and execute the command:

     find . -print|grep "\.[ch]$" | xargs etags

   This will build a file called `gnugo-3.4.x/TAGS'. Now to find any
GNU Go function, type `M-.' and enter the command which you wish to
find, or just `RET' if the cursor is at the name of the function sought.

   The first time you do this you will be prompted for the location of
the TAGS table.  Enter the path to `gnugo-3.4.x/TAGS', and henceforth
you will be able to find any function with a minimum of keystrokes.


File: gnugo.info,  Node: Analyzing,  Next: Move Generation,  Prev: Overview,  Up: Top

Analyzing GNU Go's moves
************************

   In this chapter we will discuss methods of finding out how GNU Go
understands a given position. These methods will be of interest to
anyone working on the program, or simply curious about its workings.

   In practice, most tuning of GNU Go is done in conjunction with
maintaining the `regression/' directory (*note Regression::).

   We assume that you have a game GNU Go played saved as an sgf file,
and you want to know why it made a certain move.

* Menu:

* Traces::			Analyzing traces in GNU Go 3.4
* Output File::			The Output File
* Decide string::		Checking the reading code
* Decide dragon::		Checking the owl code
* GTP and GDB techniques::      GTP and GDB techniques
* Debugboard::                  Debugboard
* Scoring::                     Finding out the winner of the game
* Colored Display::             Colored Display


File: gnugo.info,  Node: Traces,  Next: Output File,  Up: Analyzing

Interpreting Traces
===================

   A quick way to find out roughly the reason for a move is to run

     gnugo -l FILENAME -t -L MOVE NUMBER

   (You may also want to add `--quiet' to suppress the copyright
message.) In GNU Go 3.4, the moves together with their reasons are
listed, followed by a numerical analysis of the values given to each
move.

   If you are tuning (*note Tuning::) you may want to add the `-a'
option. This causes GNU Go to report all patterns matched, even ones
that cannot affect the outcome of the move. The reasons for doing this
is that you may want to modify a pattern already matched instead of
introducing a new one.

   If you use the `-w' option, GNU Go will report the statuses of worms
and dragons around the board. This type of information is available by
different methods, however (*note Debugboard::, *note Colored
Display::).

