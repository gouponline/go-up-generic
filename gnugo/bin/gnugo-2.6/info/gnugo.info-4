This is gnugo.info, produced by makeinfo version 4.0 from gnugo.texi.


File: gnugo.info,  Node: Tuning,  Next: Autohelpers,  Prev: Moyo Assistance,  Up: Patterns

Moyo Assistance
===============

   Since the pattern database decides GNU Go's personality to a very
great extent, much time can be devoted to "tuning" it.  Here are some
suggestions.

   If you want to experiment with modifying the pattern database, invoke
with the `-a' option.  This will cause every pattern to be evaluated,
even if its maximum possible contribution is smaller than a pattern
already found. This makes the program less efficient, but then you can
see how much you must increase a pattern value in order to `promote' a
better move over the move actually chosen.

   You can obtain a Smart Go Format (SGF) record of your game in at
least two different ways. One is to use CGoban to record the game. You
can also have GNU Go record the game in Smart Go Format, using the `-o'
option. It is best to combine this with `-a'. Do not try to read the
sgf file until the game is finished and you have closed the sgf window.
This does not mean that you have to play the game out to its
conclusion. You may close the CGoban window on the game and GNU Go will
close the sgf file so that you can read it.

   If you record a game in SGF form using the `-o' option, GNU Go will
add labels to the board to show all the moves it considered, with their
values. This is an extremely useful feature, since one can see at a
glance whether the right moves with appropriate weights are being
proposed by the pattern matcher. If bad moves are being proposed, one
may modify a pattern to exclude it, or reduce the value of the pattern.
If important moves are not proposed at all, you may have found a gap
in the pattern database, and you can add a pattern. If the right move
is proposed but with too low a score, this may be a sign that you
should adjust its weight upwards. It is almost always best to make the
*minimum* adjustment needed to correct the bad behavior.

   If you decide to add a pattern, give some thought to adding the
pattern in exactly the right generality by putting `?' at irrelevant
locations, and by using the `o' and `x' options.

   First, due to a bug of unknown nature, it occasionally happens that
GNU Go will not receive the SIGTERM signal from CGoban that it needs to
know that the game is over. When this happens, the sgf file ends
without a closing parenthesis, and CGoban will not open the file. You
can fix the file by typing:

      echo ")" >>[filename]

   at the command line to add this closing parenthesis. Or you could
add the ")" using an editor.

   Pattern weights exceeding 99 can be displayed by CGoban but you may
have to resize the window in order to see all three digits. Grab the
lower right margin of the CGoban window and pull it until the window is
large. All three digits should be visible.

   If you are playing a game without the -o option and you wish to
analyze a move, you may still use CGoban's "Save Game" button to get an
SGF file. It will not have the values of the moves labelled, of course.

   Once you have a game game saved in SGF format, you can analyze any
particular move by running:

       gnugo -l [filename] -L [move number] -t -a -w

   to see why GNU Go made that move, and if you make changes to the
pattern database and recompile the program, you may ask GNU Go to
repeat the move to see how the behavior changes.

   Alternatively, you can use the CGoban tools to delete all moves after
and including the one you want to study, and then load without the `-L'
option.

   If a pattern is contributing a bad move, you can adjust its weight
downward, or you you can adjust the weight of a pattern which is
contributing a good move up. If no pattern is contributing the move
that you think should be made, then you may add a pattern.

   You can also get a visual display of the dragons using the -T
option. The default GNU Go configuration tries to build a version with
color support using either curses or the ansi escape sequences. You are
more likely to find color support in rxvt than xterm, at least on many
systems, so we recommend running:

       gnugo -l [filename] -L [move number] -T

   in an rxvt window. If you do not see a color display, and if your
host is a GNU/Linux machine, try this again in the Linux console.

   Worms belonging to the same dragon are labelled with the same
letters.  The colors indicate the value of the field `dragon.safety',
which is set in `moyo.c'.

Green:  GNU Go thinks the dragon is alive
Yellow: Status unknown
Blue:   GNU Go thinks the dragon is dead
Red:    Status critical (1.5 eyes) or weak by the algorithm
        in `moyo.c'

   If you want to get the same game over and over again, you can
eliminate the randomness in GNU Go's play by changing the value of seed
in main.c to a fixed nonzero integer. If `seed==0', then GNU Go will
play a different game each time.


File: gnugo.info,  Node: Autohelpers,  Next: Autohelper Functions,  Prev: Tuning,  Up: Patterns

Autohelpers
===========

   In addition to the hand-written helper functions in helpers.c there
can be automatic helper functions. These are briefly described in the
pattern database and compiled into C source which goes into
`patterns.c'.

   The "pattern compiler" is based on the idea of constraint diagrams
and expressions. To give an example, one pattern consists of a pair of
diagrams:

     Pattern ED54
     
     |oOOX           maybe capture corner
     |..XO
     |.*XO
     |..??
     +----
     
     :8,85,0,s,10,0,0,0,0,NULL
     
     |obbX
     |..Aa
     |.*Aa
     |..??
     +----
     
     ;(lib(A)<=4) && (lib(a)>=lib(A)-1) && (lib(b)>=lib(A))
     ;&& (!dead(A)||attack(a))

   The first diagram and the colon line has exactly the same
interpretation as usual. The diagram below and the semicolon line(s)
are optional and can only be used to reject the pattern given above.
Note that some strings now have labels which are referred to in the
constraint.

   Only strings for which we have constraints need be labeled. Labels
may be any letter except OoXxt. To make the database consistent and
easy to read it is our convention that `X' strings should be upper-case
and `O' strings lower-case, but the implementation does not enforce
this.  Neither does it require that all stones in a string be labeled
(it goes with the first appearance) but it is good practice to do so
anyway.

   The constraint expression is transformed by mkpat into an
automatically generated helper function (there is a new field in the
pattern struct, so it does not conflict with the old helper). `lib(x)'
can be regarded as a macro which is expanded by mkpat into
`worm[xi][xj].liberties'. The resulting expression must be valid C code,
otherwise the generated `patterns.c' won't compile. In principle any
code can be written on the line but to keep the database maintainable
we should restrict ourselves to boolean and arithmetic expressions,
which anyone should be able to understand and write with no more than a
little trouble. If the expression evaluates to true the pattern is
accepted by the autohelper, if false it is rejected. If there are
multiple semicolon lines for the same pattern, these are concatenated
before generating the code.


File: gnugo.info,  Node: Autohelper Functions,  Next: Pattern Matcher,  Prev: Autohelpers,  Up: Patterns

Autohelper Functions
====================

     lib(x)
     lib2(x)
     lib3(x)
     lib4(x)

   Number of first, second, third, and fourth order liberties of a worm
respectively (*note Dragon::).

     xlib(x)
     olib(x)

   The number of liberties that an enemy or own stone, respectively,
would obtain if played at the empty intersection x.

     ko(x)

   True if x is either a stone or an empty point involved in a ko
position.

     status(x)
     alive(x)
     unknown(x)
     critical(x)
     dead(x)

   Status of a dragon. `status(x)' returns an integer that can have the
values `ALIVE', `UNKNOWN', `CRITICAL', or `DEAD'. The four other
functions returns true if the dragon has the corresponding status and
false otherwise (*note Dragon::).

     genus(x)

   The number of eyes of a dragon. It is only meaningful to compare this
value against 0, 1, or 2.

     xarea(x)
     oarea(x)
     xmoyo(x)
     omoyo(x)
     xterri(x)
     oterri(x)

   Functions related to various kinds of influence and territory
estimations (*note Moyo::). `xarea(x)' evaluates to true if `x' is
either a living enemy stone or an empty point within his "area".
`oarea(x)' is analogous but with respect to our stones and area.

   `cutstone(x)' returns `worm[x].cutstone', which can be 0, 1, or 2
(*note Dragon::).

     weak(x)

   True for a dragon with `safety==CRITICAL'.

     attack(x)
     defend(x)

   These give the results of tactical reading. `attack(x)' is true if
the worm can be captured, `defend(x)' is true if there also is a
defending move. Please notice that `defend(x)' will return false if
there is no attack on the worm.

     safe_xmove(x)
     safe_omove(x)

   True if an enemy or own stone, respectively, can safely be played at
`x'. By safe it is understood that the move is legal and that it cannot
be captured right away.

     odefend_against(x,y)
     xdefend_against(x,y)

   True if an own stone at `x' would stop the enemy from safely playing
at `y', and conversely for the second function.

     does_defend(x,y)
     does_attack(x,y)

   True if a move at `x' defends/attacks the worm at `y'. For defense a
move of the same color as `y' is tried and for attack a move of the
opposite color.

     xplay_defend(a,b,c,...,z)
     oplay_defend(a,b,c,...,z)
     xplay_attack(a,b,c,...,z)
     oplay_attack(a,b,c,...,z)

   These functions make it possible to do more complex reading
experiments in the constraints. All of them work so that first the
sequence of moves `a', `b', `c',... is played through with alternating
colors, starting with `X' or `O' as indicated by the name. Then it is
tested whether the worm at `z' can be attacked or defended,
respectively. It doesn't matter who would be in turn to move, a worm of
either color may be attacked or defended. For attacks the opposite
color of the string being attacked starts moving and for defense the
same color starts. The defend functions return true if the worm cannot
be attacked in the position or if it can be attacked but also defended.
The attack functions return true if there is a way to capture the
worm, whether or not it can also be defended.

     eye(x)
     proper_eye(x)
     marginal_eye(x)

   True if `x' is an eye space for either color, a non-marginal eye
space for either color, or a marginal eye space for either color,
respectively.


File: gnugo.info,  Node: Pattern Matcher,  Next: Symmetry,  Prev: Autohelper Functions,  Up: Patterns

Pattern Matcher
===============

   The pattern code in GNU Go 2.6 is fairly straightforward
conceptually, but because the matcher consumes a significant part of
the time in choosing a move, the code is optimized for speed. Because
of this there are implementation details which obscure things slightly.

   In GNU Go 2.6, the ascii patterns.db file is precompiled into tables
(see patterns.h) by a standalone program mkpat.c, and the resulting
file patterns.c is compiled and linked into the main gnugo executable.

   Each pattern is compiled to a header, and a sequence of elements,
which are (notionally) checked sequentially at every position and
orientation of the board. These elements are relative to the pattern
'anchor' (or origin).  One `X' or `O' stone is (arbitrarily) chosen to
represent the origin of the pattern. (We cannot dictate one or the
other since some patterns contain only one colour or the other.)  All
the elements are in co-ordinates relative to this position. So a
pattern matches "at" board position (m,n,o) if the the pattern anchor
stone is on (m,n), and the other elements match the board when the
pattern is transformed by transformation number 'o'. (See below for the
details of the transformations, though these should not be necessary)


File: gnugo.info,  Node: Symmetry,  Next: Matcher Details,  Prev: Pattern Matcher,  Up: Patterns

Symmetry and Transformations
============================

   In general, each pattern must be tried in each of 8 different
permutations, to reflect the symmetry of the board. But some patterns
have symmetries which mean that it is unnecessary (and therefore
inefficient) to try all eight. The first character after the ':' can be
one of '8','|','\','/', 'X', '-', '+', representing the axes of
symmetry.

     transformation   I    -    |     .     \    l    r     /
                     ABC  GHI  CBA   IHG   ADG  CFI  GDA   IFC
                     DEF  DEF  FED   FED   BEH  BEH  HEB   HEB
                     GHI  ABC  IHG   CBA   CFI  ADG  IFC   GDA
     
                      a    b    c     d     e    f    g     h

   Then if the pattern has the following symmetries, the following are
true...

     |  c=a, d=b, f=e, h=g
     -  b=a, c=d, e=f, g=i
     \  e=a, g=c, f=b, h=d
     /  h=a, f=c, g=b, e=d
     X  a=d=e=h, b=c=f=g
     +  a=b=c=d, e=f=g=h

   We can choose to use transformations a,d,f,g  as the unique
transformations for patterns with either `|' or `\' symmetry.

   Thus we choose to order the transformations a,f,d,g,.... and choose
first 2 for `X' and `-', the first 4 for `|', `-', `/', and `\', and
all 8 for non-symmetrical patterns.


File: gnugo.info,  Node: Matcher Details,  Next: Grid Optimization,  Prev: Symmetry,  Up: Patterns

Matcher Details
===============

   i) An entry in the pattern header states whether the anchor is an X
or an O. This helps performance, since all transformations can be
rejected at once if the anchor stone does not match. (Ideally, we could
just define that the anchor is always O or always X, but some patterns
contain no O's and some contain no X's.)

   ii) The pattern header contains the size of the pattern (ie the
co-ordinates of the top left and bottom right elements) relative to the
anchor. This allows the pattern can be rejected quickly if there is not
room for the pattern to fit around the anchor stone in a given
orientation (ie it is too near the edge of the board).  The bounding
box information must first be transformed like the elements before it
can be tested, and after transforming, we need to work out where the
top-left and bottom-right corners are.

   iii) The edge constraints are implemented by notionally padding the
pattern with rows or columns of '?' until it is exactly 19 elements
wide or high. Then the pattern is quickly rejected by (ii) above if it
is not at the edge. So the example pattern above is compiled as if it
was written

     "example"
     .OO????????????????
     *XX????????????????
     o??????????????????
     :8,80

   iv) The elements in a pattern are sorted so that non-space elements
are checked before space elements. It is hoped that, for most of the
game, more squares are empty, and so the pattern can be more quickly
rejected doing it this way.

   v) The patterns themselves are sorted by decreasing maximum-weight,
which is the maximum value the pattern can take, taking weight and wind
assistance into account.  For this to work, the weight stored for
patterns with helpers must be the maximum which the helper can return.
As a hint, to simplify maintenance, the helper can access the stored
weight from the pattern structure passed in.

   vi) The actual tests are performed using an 'and-compare' sequence.
Each board position is a 2-bit quantity.  %00 for empty, %01 for O, %10
for X.  We can test for an exact match by and-ing with %11 (no-op),
then comparing with 0, 1 or 2. The test for 'o' is the same as a test
for 'not-X', ie not %10. So and with %01 should give 0 if it matches.
Similarly 'x' is a test that bit 0 is not set.


File: gnugo.info,  Node: Grid Optimization,  Next: Joseki Compiler,  Prev: Matcher Details,  Up: Patterns

The "Grid" Optimization
=======================

   This is a compile time option. By editing the makefile, you can use
this faster code to match patterns. The only disadvantage to using this
code is that it might be harder to understand and debug.

   As described in (vi), the comparisons between pattern and board are
performed as 2-bit bitwise operations. Therefore they can be performed
in paralled, 16-at-a-time on a 32-bit machine.

   Suppose the board is layed out as follows :

      .X.O....OO
      XXXXO.....
      .X..OOOOOO
      X.X.......
      ....X...O.

   which is internally stored internally in a 2d array (binary)

      00 10 00 01 00 00 00 00 01 01
      10 10 10 10 01 00 00 00 00 00
      00 10 00 00 01 01 01 01 01 01
      10 00 10 00 00 00 00 00 00 00
      00 00 00 00 10 00 00 00 01 00

   we can compile this to a composite array in which each element
stores the state of a 4x4 grid of squares :

      ????????  ????????  ???????? ...
      ??001000  00100001  10000100
      ??101010  10101010  10101001
      ??001000  00100000  10000001
     
      ??001000  00100001  ...
      ??101010  10101010
      ??001000  00100000
      ??001000  10001000
     ...
     
      ??100010  ...
      ??000000
      ????????
      ????????

   Where '??' is off the board.

   We can store these 32-bit composites in a 2d merged-board array,
substituting the illegal value %11 for '??'.

   Similarly, for each pattern, mkpat produces appropriate 32-bit
and-value masks for the pattern elements near the anchor. It is a
simple matter to test the pattern with a similar test to (vi) above,
but for 32-bits at a time.


File: gnugo.info,  Node: Joseki Compiler,  Next: Advanced Features,  Prev: Grid Optimization,  Up: Patterns

The Joseki Compiler
===================

   GNU Go includes a joseki compiler in patterns/joseki.c. This
processes an sgf file (with variations) and produces a sequence of
patterns which can then be fed back into mkpat. The joseki database is
in files in `patterns/' called `hoshi.sgf', `komoku.sgf', `sansan.sgf',
`mokuhadzushi.sgf' and `takamoku.sgf'.

   Not every node in the sgf file contributes a pattern. The nodes
which contribute patterns have the joseki in the upper right corner,
with the boundary marked with an `A' and the value given by a comment.


File: gnugo.info,  Node: Advanced Features,  Next: Connection Patterns,  Prev: Joseki Compiler,  Up: Patterns

Advanced Features
=================

   The joseki compiler is able to generate a constraint line in the
`.db'.  The square symbol is a shortcut for `oarea()', the triangle is
`xarea()' and the circle is `(!oarea()&&!xarea())' = an empty area.

   The delimiter between value and classification in the SGF comment
must be `;', for example:

     81;
     D

   Spaces and `\n' may be omitted.

   These features are experimental and are currently not used in the
joseki files.


File: gnugo.info,  Node: Connection Patterns,  Prev: Advanced Features,  Up: Patterns

Connection Patterns
===================

   The patterns in `patterns/conn.db' are compiled separately from the
other patterns. When a `B' pattern is found, a cutting point is set in
the worm data structure and make eye space marginal for the connection
inhibiting entries of the pattern. If it is a C pattern, amalgamate the
dragons in the pattern.


File: gnugo.info,  Node: Reading,  Next: Utility Functions,  Prev: Patterns,  Up: Top

Reading
*******

   The process of visualizing potential moves done by you and your
opponent to learn the result of different moves is called "reading".

* Menu:

* Reading Basics::              Reading Basics
* Hashing::                     Hashing of positions
* Debugging::                   Debugging the reading code


File: gnugo.info,  Node: Reading Basics,  Next: Hashing,  Prev: Reading,  Up: Reading

Reading Basics
==============

   In GNU Go, this is done by the functions in `engine/reading.c'. Each
of these functions has a separate goal to fill, and they call each other
recursively to carry out the reading process.

   The reading code makes use of a stack onto which board positions can
be pushed. The parameter `stackp' is zero if GNU Go is examining the
true board position; if it is higher than zero, then GNU Go is
examining a hypothetical position obtained by playing several moves.

   Many of the reading functions make use of *null pointers*.  For
example, a call to `attack(i, j, &ai, &aj)' will return 1 if the string
at `(i, j)' can be captured, 2 or 3 if it can be attacked with ko, and
0 if it is safe. The point of attack (in case it is vulnerable) is
returned in `(ai, aj)'. However many times we do not care about the
point of attack. In this case, we can substitute a null pointer:
`attack(i, j, NULL, NULL)'.

   Depth of reading is controlled by a parameter `depth'.  This has a
default value `DEPTH' (in `liberty.h'), which is set to 14 in the
distribution, but it may also be set at the command line using the -D
option. If `depth' is increased, GNU Go will be stronger and slower.
GNU Go will read moves past depth, but in doing so it makes simplifying
assumptions that can cause it to miss moves.

   Specifically, when `stackp > depth', GNU Go assumes that as soon as
the string can get 3 liberties it is alive. This assumption is
sufficient for reading ladders.

   Currently the reading code does not try to defend a string by
attacking a boundary string with more than two liberties. Because of
this restriction, it can make oversights. A symptom of this is two
adjacent strings, each having three or four liberties, each classified
as `DEAD'. To resolve such situations, a function `small_semeai()' (in
`engine/semeai.c') looks for such pairs of strings and corrects their
classification.

   The backfill_depth is a similar variable with a default 10. Below
this depth, GNU Go will try "backfilling" to capture stones.  For
example in this situation:


     .OOOOOO.    on the edge of the board, O can capture X but
     OOXXXXXO    in order to do so he has to first play at a in
     .aObX.XO    preparation for making the atari at b. This is
     --------    called backfilling.

   Backfilling is only tried with `stackp <= backfill_depth'. The
parameter `backfill_depth' may be set using the `-B' option.

   The `fourlib_depth' is a parameter with a default of only 5.  Below
this depth, GNU Go will try to attack strings with four liberties. The
`fourlib_depth' may be set using the `-F' option.

   The parameter `ko_depth' is a similar cutoff. If `stackp<ko_depth',
the reading code will make experiments involving taking a ko even if it
is not legal to do so (i.e., it is hypothesized that a remote ko threat
is made and answered before continuation).  This parameter may be set
using the `-K' option.

   The reading functions generally return 1 for success, and 0 for
failure. If the result depends on ko, they return 2 or 3.  A return
code of 2 means that the attack or defense is successful provided the
attacker or defender is willing to ignore a ko threat; a return code of
3 means the attack or defense is successful provided the player can
come up with a sufficiently large ko threat.

   A partial list of the functions in `reading.c':

   * `int attack(int m, int n, int *i, int *j)':
          The basic function `attack(m, n, *i, *j)' determines if the
          string at `(m, n)' can be attacked, and if so, `(*i, *j)'
          returns the attacking move, unless `*i' and `*j' are null
          pointers. (Use null pointers if you are interested in the
          result of the attack but not the attacking move itself.)
          Returns 1 if the attack succeeds, otherwise 0. Returns 2 or 3
          if the result depends on ko: returns 2 if the attack succeeds
          provided attacker is willing to ignore any ko threat. Returns
          3 if attack succeeds provided attacker has a ko threat which
          must be answered.

   * `find_defense(int m, int n, int *i, int *j)':
          The function `find_defense(m, n, *i, *j)' attempts to find a
          move that will save the string at `(m,n)'. It returns true if
          such a move is found, with `(*i, *j)' the location of the
          saving move (unless `(*i, *j)' are null pointers). It is not
          checked that tenuki defends, so this may give an erroneous
          answer if `!attack(m,n)'.  Returns 2 or 3 if the result
          depends on ko. Returns 2 if the string can be defended
          provided (color) is willing to ignore any ko threat. Returns
          3 if (color) has a ko threat which must be answered.

   * `safe_move(int i, int j, int color)' :
          The function `safe_move(i, j, color)' checks whether a move at
          `(i, j)' is illegal or can immediately be captured. If
          `stackp==0' the result is cached. If the move only can be
          captured by a ko, it's considered safe. This may or may not
          be a good convention.

   The next few functions are essentially special cases of `attack' and
`find_defense'. They are coded individually.

   * `attack2(int m, int n, int *i, int *j)' :
          Determine whether a string with 2 liberties can be captured.
          Usage is similar to `attack'.

   * `attack3(int m, int n, int *i, int *j)' :
          Determine whether a string with 3 liberties can be captured.
          Usage is similar to `attack'.

   * `attack4(int m, int n, int *i, int *j)' :
          Determine whether a string with 4 liberties can be captured.
          Usage is similar to `attack'.

   * `defend1(int m, int n, int *i, int *j)' :
          Determine whether a string with 1 liberty can be rescued.
          Usage is similar to `find_defense'.

   * `defend2()' :
          Determine whether a string with 2 liberties can be rescued.
          Usage is similar to `find_defense'.

   * `defend3()' :
          Determine whether a string with 3 liberties can be rescued.
          Usage is similar to `find_defense'.

   * `find_cap2()' :
          If `(m,n)' points to a string with 2 liberties,
          `find_cap2(m,n,&i,&j)' looks for a configuration:

                 O.
                 .*
          where `O' is an element of the string in question. It
          tries the move at `*' and returns true this move captures the
          string, leaving `(i,j)' pointing to *.

   * `chainlinks(int m, int n, int *adj,   int adji[MAXCHAIN], int
     adjj[MAXCHAIN], int adjsize[MAXCHAIN],   int adjlib[MAXCHAIN])':
          Find the CHAIN surrounding a string. This is the set of
          adjacent strings of the opposite color. The function
          `chainlinks()' returns (in `adji', `adjj' arrays) these
          strings surrounding the group at `(i, j)'. If `stackp <=
          depth', these are sorted by size (largest first). The size
          and number of liberties of each string are returned in
          `adjsize' and `adjlib'.

   * `break_chain(int si, int sj, int *i, int *j, int *k, int *l)':
          The function `break_chain(si, sj, *i, *j, *k, *l)' returns 1
          if part of some surrounding string is in atari, and if
          capturing this string results in a live string at `(si, sj)'.
          Returns 2 if the capturing string can be taken (as in a
          snapback), or the the saving move depends on ignoring a ko
          threat; Returns 3 if the saving move requires making a ko
          threat and winning the ko. The pointers `(i,j)', if not NULL,
          are left pointing to the appropriate defensive move. The
          pointers `(k,l)', if not NULL, are left pointing to the
          boundary string which is in atari.

   * `break_chain2(int si, int sj, int *i, int *j)':
          The function `break_chain2(si, sj, *i, *j)' returns 1 if
          there is a string in the surrounding chain having exactly two
          liberties whose attack leads to the rescue of `(si, sj)'.
          Then *i, *j points to the location of the attacking move.
          Returns 2 if the attacking stone can be captured, 1 if it
          cannot.

   * `snapback(snapback(int si, int sj, int i, int j, int color)':
          The function `snapback(si, sj, i, j, color)' considers a move
          by color at `(i, j)' and returns true if the move is a
          snapback.  Algorithm: It removes dead pieces of the other
          color, then returns 1 if the stone at `(si, sj)' has <2
          liberties. The purpose of this test is to avoid snapbacks.
          The locations `(i, j)' and `(si,sj)' may be either same or
          different. Also returns 1 if the move at `(i, j)' is illegal,
          with the trace message "ko violation" which is the only way I
          think this could happen. It is not a snapback if the
          capturing stone can be recaptured on its own, e.g.

                 XXOOOOO
                 X*XXXXO
                 -------
          Here `O' capturing at `*' is in atari, but this is not a
          snapback. Use with caution: you may want to condition the
          test on the string being captured not being a singleton. For
          example

                 XXXOOOOOOOO
                 XO*XXXXXXXO
                 -----------
          is rejected as a snapback, yet `O' captures more than it
          gives up.


File: gnugo.info,  Node: Hashing,  Next: Debugging,  Prev: Reading Basics,  Up: Reading

Hashing of positions
====================

   To speed up the reading process, we note that a position can be
reached in several different ways.  In fact, it is a very common
occurrence that a previously checked position is rechecked, often
within the same search but from a different branch in the recursion
tree.

   This wastes a lot of computing resources, so in a number of places,
we store away the current position, the function we are in, and which
worm is under attack or to be defended.  When the search for this
position is finished, we also store away the result of the search and
which move made the attack or defense succeed.

   All this data is stored in a hash table where Go positions are the
key and results of the reading for certain functions and groups are the
data. You can increase the size of the Hash table using the `-M' or
`--memory' option *note Invoking GNU Go::.

   The hash table is created once and for all at the beginning of the
game by the function `hashtable_new()'. Although hash memory is thus
allocated only once in the game, the table is reinitialized at the
beginning of each move by a call to `hashtable_clear()' from
`genmove()'.

* Menu:

* Hash Calculation::            Calculation of the hash value.
* Hash Organization::           Organization of the hash table.


File: gnugo.info,  Node: Hash Calculation,  Next: Hash Organization,  Prev: Hashing,  Up: Hashing

Calculation of the hash value
-----------------------------

   The hash algorithm is called Zobrist hashing, and is a standard
technique for go and chess programming. The algorithm as used by us
works as follows:

  1. First we define a GO POSITION.  This positions consists of
        * the actual board, i.e. the locations and colors of the stones

        * A ko point, if a ko is going on.  The ko point is defined as
          the empty point where the last single stone was situated
          before it was captured.

     It is not necessary to specify the color to move (white or black)
     as part of the position. The reason for this is that read results
     are stored separately for the various reading functions such as
     `attack3', and it is implicit in the calling function which player
     is to move.

  2. For each location on the board we generate random numbers:
        * A number which is used if there is a white stone on this
          location

        * A number which is used if there is a black stone on this
          location

        * A number which is used if there is a ko on this location

     These random numbers are generated once at initialization time and
     then used throughout the life time of the hash table.

  3. The hash key for a position is the XOR of all the random numbers
     which are applicable for the position (white stones, black stones,
     and ko position).


File: gnugo.info,  Node: Hash Organization,  Prev: Hash Calculation,  Up: Hashing

Organization of the hash table
------------------------------

   The hash table consists of 3 parts:

   * An area which contains so called Hash Nodes. Each hash node
     contains:
        - A go position as defined above.

        - A computed hash value for the position

        - A pointer to Read Results (see below)

        - A pointer to another hash node.

   * An area with so called Read Results.  These are used to store
     which function was called in the go position, which string was
     under attack or to be defended, and the result of the reading.

     Each Read Result contains:
        - the function ID (an int between 0 and 255), the position of
          the string under attack and a depth value, which is used to
          determine how deep the search was when it was made, packed
          into one 32 bit integer.

        - The result of the search (a numeric value) and a position to
          play to get the result packed into one 32 bit integer.

        - A pointer to another Read Result.

   * An array of pointers to hash nodes.  This is the hash table proper.


   When the hash table is created, these 3 areas are allocated using
`malloc()'.  When the hash table is populated, all contents are taken
from the Hash nodes and the Read results. No further allocation is done
and when all nodes or results are used, the hash table is full.
Nothing is deleted from the hash table except when it is totally
emptied, at which point it can be used again as if newly initialized.

   When a function wants to use the hash table, it looks up the current
position using `hashtable_search()'. If the position doesn't already
exist there, it can be entered using

   `hashtable_enter_position()'.

   Once the function has a pointer to the hash node containing a
function, it can search for a result of a previous search using
`hashnode_search()'.  If a result is found, it can be used, and if not,
a new result can be entered after a search using
`hashnode_new_result()'.

   Hash nodes which hash to the same position in the hash table
(collisions) form a simple linked list.  Read results for the same
position, created by different functions and different attacked or
defended strings also form a linked list.

   This is deemed sufficiently efficient for now, but the representation
of collisions could be changed in the future.  It is also not
determined what the optimum sizes for the hash table, the number of
positions and the number of results are.


File: gnugo.info,  Node: Debugging,  Prev: Hashing,  Up: Reading

Debugging the reading code
==========================

   The reading code searches for a path through the move tree to
determine whether a string can be captured. We have a tool for
investigating this with the `--decidestring' option. This may be run
with or without an output file.

   Simply running


     `gnugo -t -l [input file name] -L [movenumber] --decidestring [location]'

   will run `attack()' to determine whether the string can be captured.
If it can, it will also run `find_defense()' to determine whether or
not it can be defended. It will give a count of the number of
variations read. The `-t' is necessary, or else GNU Go will not report
its findings.

   If we add `-o OUTPUT FILE' GNU Go will produce an output file with
all variations considered. The variations are numbered in comments.

   This file of variations is not very useful without a way of
navigating the source code. This is provided with the GDB source file,
listed at the end. You can source this from GDB, or just make it your
GDB init file.

   If you are using GDB to debug GNU Go you may find it less confusing
to compile without optimization. The optimization sometimes changes the
order in which program steps are executed. For example, to compile
`reading.c' without optimization, edit `engine/Makefile' to remove the
string `-O2' from the file, touch `engine/reading.c' and make. Note
that the Makefile is automatically generated and may get overwritten
later.

   If in the course of reading you need to analyze a result where a
function gets its value by returning a cached position from the hashing
code, rerun the example with the hashing turned off by the command line
option `--hash 0'. You should get the same result. (If you do not,
please send us a bug report.) Don't run `--hash 0' unless you have a
good reason to, since it increases the number of variations.

   With the source file given at the end of this document loaded, we
can now navigate the variations. It is a good idea to use cgoban with a
small `-fontHeight', so that the variation window takes in a big
picture. (You can resize the board.)

   Suppose after perusing this file, we find that variation 17 is
interesting and we would like to find out exactly what is going on here.

   The macro 'jt n' will jump to the n-th variation.


     (gdb) set args -l [filename] -L [move number] --decidestring [location]
     (gdb) tbreak main
     (gdb) run
     (gdb) jt 17

   will then jump to the location in question.

   Actually the attack variations and defense variations are numbered
separately. (But `find_defense()' is only run if `attack()' succeeds,
so the defense variations may or may not exist.) It is redundant to
have to tbreak main each time. So there are two macros avar and dvar.


     (gdb) avar 17

   restarts the program, and jumps to the 17-th attack variation.


     (gdb) dvar 17

   jumps to the 17-th defense variation. Both variation sets are found
in the same sgf file, though they are numbered separately.

   Other commands defined in this file:



     `dump' will print the move stack.
     `nv' moves to the next variation
     `ascii i j' converts (i,j) to ascii
     
     #######################################################
     ###############      .gdbinit file      ###############
     #######################################################
     
     # this command displays the stack
     
     define dump
     set dump_stack()
     end
     
     # display the name of the move in ascii
     
     define ascii
     set gprintf("%o%m\n",$arg0,$arg1)
     end
     
     # move to the next variation
     
     define nv
     tbreak trymove
     continue
     finish
     next
     end
     
     # move forward to a particular variation
     
     define jt
     while (count_variations < $arg0)
     nv
     end
     nv
     dump
     end
     
     # restart, jump to a particular attack variation
     
     define avar
     delete
     tbreak sgf_decidestring
     run
     tbreak attack
     continue
     jt $arg0
     end
     
     # restart, jump to a particular defense variation
     
     define dvar
     delete
     tbreak sgf_decidestring
     run
     tbreak attack
     continue
     finish
     next 3
     jt $arg0
     end


File: gnugo.info,  Node: Utility Functions,  Next: End Game,  Prev: Reading,  Up: Top

Utility Functions
*****************

   Here are some common utility functions from `engine/utils.c'.

   * `int pushgo()'
          Pushes the position onto the stack.

   * `int popgo()'
          Pops the movestack.

   * `int trymove(int i, int j, int color, const char *message, int k,
     int l)'
          Returns true if `(i,j)' is a legal move for color. In that
          case, it pushes the move on the stack and makes the move,
          incrementing `stackp'. If the reading code is recording
          reading variations (as with `--decide_string' or with `-o'),
          the string `*message' will be inserted in the SGF file as a
          comment. The comment will also refer to the string at `(k,l)'
          if these are not `(-1,-1)'.  Use like this:

                  if (trymove(i, j, color, [message], k, l)) {
                       ...
                       popgo();
                  }

   * `int TRY_MOVE()'
          Wrapper around trymove which suppresses `*message' and
          `(k,l)'.  Used in `helpers.c'

   * `tryko(int i, int j, int color, const char *message)'
          Pushes the position onto the stack, and makes a move at
          `(i,j)' of `color'. The move is allowed even if it is an
          illegal ko capture.  It is to be imagined that `color' has
          made an intervening ko threat which was answered and now the
          continuation is to be explored.

   * `dump_stack(void)'
          Handy for debugging the reading code under GDB. Prints the
          move stack.

   * `vgprintf(FILE* outputfile, const char *fmt, va_list ap)'
          This function underpins all the `TRACE' and `DEBUG' stuff.
          Accepts `%c', `%d' and `%s' as usual. But it also accepts
          `%m', which takes TWO integers and writes a move *NASTY
          BODGE*: `%o' at start means outdent (ie cancel indent).

   * `void TRACE(const char *fmt, ...)'
          Basic tracing function. Variants `RTRACE', etc. are
          documented in the source.

   * `int legal(int i, int j, int color)'
          Returns true if `(i,j)' is legal for `color'.

   * `int count(int i, int j, int color, char mx[MAX_BOARD][MAX_BOARD],
     int maxlib, char mark)'
          Count liberties of color piece at location `(i, j)' and return
          value in global variable `lib' (which is also the return
          value of the function). Return size of connected component in
          `size'. If `k<lib', then `(libi[k],libj[k])' points to one of
          the liberties of the string. *FIXME*: We should get rid of
          these global variables. This function is usually called with
          a stone of `color' at `(i,j)'. It may also be called with
          `(i,j)' `EMPTY'. If this is the case, the function
          (essentially) places a stone of (color) on the board and does
          the calculation.

   * `void change_dragon_status(int x, int y, int status)'
          Change the status of the dragon at `(x,y)'.

   * `void change_defense(int ai, int aj, int ti, int tj)'
          Moves the point of defense of `(ai, aj)' to `(ti, tj)'.
          *FIXME*: At present can only set defend_code equal to 1 or 0.

   * `void change_attack(int ai, int aj, int ti, int tj)'
          Moves the point of attack of the worm at `(ai, aj)' to `(ti,
          tj)'.  *FIXME*: At present can only set attack_code equal to
          1 or 0.

   * `int connection_value(int ai, int aj, int bi, int bj, int ti, int
     tj)'
          This important function assigns a value to the connection of
          two dragons.  The move at `(ti,tj)' is the connecting move.
          It is checked whether this move will result in a dragon
          having two eyes.

   * `int cut_possible(int i, int j, int color)'
          Returns true if color can cut at `(i,j)'. This information is
          collected by `find_cuts()', using the `B' patterns in the
          connections database.

   * `int does_attack(int ti, int tj, int ai, int aj)'
          Returns true if the move at `(ti, tj)' attacks `(ai, aj)'.
          This means that it captures the string, and that `(ai, aj)'
          is not already dead. As currently written, this function
          assumes `stackp==0', though this could be easily changed.

   * `int does_defend(int ti, int tj, int ai, int aj)'
          Returns true if the move at `(ti, tj)' defends `(ai, aj)'.
          This means that it defends the string, and that `(ai, aj)'
          can be captured if no defense is made. As currently written,
          this function assumes `stackp==0', though this could be
          easily changed.

   * `int find_lunch(int m, int n, int *wi, int *wj, int *ai, int *aj)'
          Looks for a worm adjoining the string at `(m,n)' which can be
          easily captured. Whether or not it can be defended doesn't
          matter (*note Dragon::). Returns the location of the string
          in `(*wi, *wj)', and the location of the attacking move in
          `(*ai, *aj)'.

   * `int is_ko(int i, int j, int color)'
          Return true if the move `(i,j)' by `color' is a ko capture
          (whether capture is a legal ko capture on this move or not).

   * `int singleton(int i, int j)'
          Return true if `(i,j)' is an isolated stone.

   * `int confirm_safety(int i, int j, int color, int value)'
          This important function will detect some blunders.  Returns 1
          if a move by `color' at `(i,j)' does not diminish the safety
          of any worm, nor tend to rescue inadvertantly an opponent
          stone.


File: gnugo.info,  Node: End Game,  Next: Regression,  Prev: Utility Functions,  Up: Top

End Game Patterns
*****************

   Endgame moves are generated just like any other move by GNU Go. In
fact, the concept of endgame does not exist explicitly, but we can
consider the endgame to be reached when the move values generally have
decreased to about 20 and the endgame patterns come into play. This is
typically fairly late, when most of the remaining plays are worth a few
points in gote.

   It should be noted that GNU Go currently makes no attempt whatsoever
to play a theoretically perfect endgame. Instead the goal is just to
play a decent, although maybe somewhat passive, endgame. What this
means is primarily to play the small endgame moves in roughly the right
order.

   The endgame is implemented by a number of patterns in `patterns.db',
classified as EE, edge endgame, or CE, center endgame. In order to play
the endgame moves in the right order, the patterns should be valued
according to a pessimistic estimation of the size of the move. If the
move is gote or reverse sente, it should have a value given by the
table below.


Value   Size
1       Fill dame, i.e. 0 points gote.
2       Fill or take an unimportant ko, 1/2 point gote.
3       1 point gote.
4       1 1/2 point gote, typically two stage unimportant ko
        or 1 point gote with a followup of one more point
        gote.
5       2 points gote or 1 point reverse sente.
7       3 points gote.
10      4 points gote or 2 points reverse sente.
15      About 6 points gote or 3 points reverse sente.
20      At least 8 points gote or at least 4 points reverse
        sente.

   Small sente moves should be valued at least 5, with the exact value
depending on the size of the followup move. Most sente moves are not
considered as endgame moves by GNU Go, neither are larger gote or
reverse sente moves. A minimal double sente move should at least have
value 10, but in most cases they should be played before the endgame.

Example
=======

     Pattern CE6
     
     X?        push in
     *O
     
     :8,1,0,0,0,0,OX,0,NULL

   A move generated from this pattern may be worth one or more points,
e.g. in the position

     XXXO
     ..*O
     XXXO

   where it is required that all stones are alive and it is assumed
that the empty points would be territory for X with a stone at *. It
could, however, also be applied in a position like

     XXXO
     .X*O
     XXXO

   where it only fills a dame. Hence the value of the pattern is no
more than 1. To get a larger value for a move in the position above, we
need to have a more specific pattern that is guaranteed to be worth at
least one point gote, e.g.

     Pattern CE6b
     
     X?        push in
     *O        1 points gote
     
     :8,3,0,OX,0,0,0,0,0,NULL
     
     X?
     aO
     
     ;marginal_eye(a)

   By taking help of the eye space evaluation we can know for certain
that this move is worth at least one point.


File: gnugo.info,  Node: Regression,  Next: Concept Index,  Prev: End Game,  Up: Top

Regression testing
******************

   the `--mode test' option of gnugo allows for testing of moves.

   generated moves are tested against annotations and actual moves


     /* ANNOTATION PROPERTIES:
     * Circle:   Good Move
     * Triangle: OK move
     * Square:   Bad move   (Mark too... cgoban writes MA instead of SQ)
     * Move that was made:  considered good unless annotated (BM, TE)
     */

Example
=======

   The regression directory contains an example `test-tree.sgf' which
shows how the testing works.  Look at it with your favorite editor,
then run it through the test to see how it performs.

   A sample test run:

     gnugo --mode test --testmode annotation --infile test-tree.sgf --quiet


File: gnugo.info,  Node: Concept Index,  Next: Functions Index,  Prev: Regression,  Up: Top

Concept Index
*************

* Menu:

* Debugging the reading code:            Debugging.
* Depth of reading:                      Reading.
* gnugo's gdb commands:                  Debugging.
* GO POSITION:                           Hash Calculation.
* Hashing of positions:                  Hashing.
* How to debug the reading code:         Debugging.
* Reading code:                          Reading.
* Reading code debugging tools:          Debugging.
* reading DEPTH:                         Reading.
* Reading optimisation:                  Hashing.
* Reading process:                       Reading.
* reading.c <1>:                         Reading Basics.
* reading.c:                             Reading.
* reading.h:                             Reading.
* speedup reading process:               Hashing.
* Trying hypothetical moves:             Reading.
* Usage of the stack in reading:         Reading.
* Using gdb to debug reading code:       Debugging.
* Using the gnu debugger with gnugo:     Debugging.
* Zobrist hashing algorithm:             Hashing.

