This is gnugo.info, produced by makeinfo version 4.0 from gnugo.texi.


File: gnugo.info,  Node: Move Generation,  Next: Roadmap,  Prev: Definitions,  Up: Overview

Move Generation
===============

   The engine of GNU Go takes a positions and a color to move and
generates the (supposedly) optimal move.  This is done by the function
`genmove()' in `engine/genmove.c'.

   The move generation is done in two passes:

  1. information gathering

  2. actual move generation based on the information gathered in pass 1.

Information gathering
---------------------

   First we have to collect as much information as possible about the
current position.  Such information could be life and death of the
groups, moyo status, connection of groups and so on. Information
gathering are performed by the following functions, called in this
order:

   - `make_worms()'
     Collect information about all connected sets of stones (strings)
     and cavities.  This information is stored in the `worm[][]' array.

   - `make_dragons'
     Collect information about connected strings, which are called
     dragons.  Important information here is number of eyes, life
     status, and connectedness between string.

   - `make_moyo()'
     Calculate the "territory", "moyo" and "area" for both sides.
     "Territory," as used here, is not solid, incontestible territory,
     but rather the regions which are deemed likely to become actual
     territory.  "Moyo" is the larger region of strong influence which
     could become territory if the other side does nothing about it.
     "Area" is a still larger region of general influence.  This
     function also assigns "weakness" to groups which are strategically
     vulnerable because of strong opposing influence. Weakness is
     accounted for in the field `dragon.safety' (see *note Dragon::).

   *Note Dragon::, for `make_worms()' and `make_dragons()' more detailed
documentation.  *Note Moyo::, for the algorithms in make_moyo.

Move generation in GNU Go 2.6
-----------------------------

   Once we have found out all about the position it is time to generate
the best move.  Moves are proposed by a number of different move
generators with a value attached to them.  The values are compared and
the best move is picked.  If two or more moves have the same value, one
of them is picked at random.

   The move generators in version 2.6 are:

   - `fuseki()'
     Generate a move in the early fuseki. This module is undocumented
     but will be replaced by something better in the future.

   - `semeai()'
     Find out if two dead groups of opposite colors are next to each
     other and, if so, try to kill the other group. This module is
     probably the one in the worst condition currently and badly in
     need of improvement.

   - `shapes()'
     Find patterns from `patterns/patterns.db' in the current position.
     Each pattern is matched in each of the 8 possible orientations
     obtainable by rotation and reflection. If the pattern matches, a
     so called "constraint" may be tested which makes use of reading to
     determine if the pattern should be used in the current situation.
     Such constraints can make demands on number of liberties of
     strings, life and death status, and reading out ladders, etc. The
     patterns may call helper functions, which may be hand coded (in
     `patterns/helpers.c') or autogenerated.

   The patterns can be of a number of different classes with different
goals.  There are e.g. patterns which try to attack or defend groups,
patterns which try to connect or cut groups, and patterns which simply
try to make good shape.

   *Note Patterns::, for a complete documentation of patterns.

   - `attacker()'
     Looks for strings of the opposite color with four liberties or
     less and tries to kill them.

   - `defender()'
     Looks for strings of my color with four liberties or less and
     tries to defend them.

   - `eye_finder()'
     Finds groups of either color which can make two eyes in the next
     move and looks for the vital point in the eye shapes.

   - `revise_semeai()'
     If no move is found yet, change status of opponent groups involved
     in a semeai from `DEAD' to `UNKNOWN'.  After this, genmove runs
     shapes again to see if a new move turns up.

   - `fill_liberty()'
     Fill a common liberty. This is only used at the end of the game.
     If necessary a backfilling or backcapturing move is generated.


File: gnugo.info,  Node: Roadmap,  Next: Data Structures,  Prev: Move Generation,  Up: Overview

Roadmap
=======

   The GNU Go engine is contained in two directories, `engine/' and
`patterns/'. Code related to the user interface, reading and writing of
smart go format files and testing are found in the directories
`interface/', `sgf/' and `regression/'. Code borrowed from other GNU
programs is contained in `utils/'. Documentation is in `docs/'.

   In this document we will describe the all individual files comprising
the engine code in `engine/' and `patterns/'. In `interface/' we
mention one file:

   `gmp.c'      :
     This is the Go Modem Protocol interface (courtesy of William
     Shubert and others). This takes care of all the details of
     exchanging setup and moves with Cgoban, or any other driving
     program recognizing the Go Modem Protocol.

   In `engine/' there are the following files:

   `attdef.c'    :
     This file contains `attacker()', `defender()' and `eye_finder()',
     three of the move generators called by `genmove()'. The module
     `attacker()' proposes moves which attack enemy strings, while
     `defender()' proposes moves which defend friendly strings. The
     reading necessary to decide whether a string can be captured or
     defended is contained in `reading.c', and has already been called
     by `make_worms()'. If a string can be defended, there may be
     different possible defensive moves, and some of the patterns found
     by `shapes()' may move the points of defense. This is the only
     case where data compiled by `make_worms()' and `make_dragons()' is
     changed by a later routine. Because of this feature, `shapes()' is
     called before `defender()'.

     Also in `attdef.c' is `eye_finder()'. This module looks for
     dragons having one and a half eyes. If such a dragon (of either
     color) is found, `eye_finder()' proposes making or destroying the
     half eye.

   `dragon.c'    :
     This contains `make_worms()' and `make_dragons()'. These routines
     are executed before the move-generating modules `shapes()',
     `attacker()', `defender()', `semeai()' and `eye_finder()'. They
     find all the worms and dragons and collect important information
     about them, such as how many liberties each has, whether (in GNU
     Go's opinion) the string or dragon can be captured, etc.  This
     information remains unchanged until the next move, with one
     exception: some patterns can move the point of defense of a
     friendly worm which is under attack.

   `filllib.c'   :
     Code to force filling of dame (backfilling if necessary) at the
     end of the game.

   `fuseki.c'    :
     This module generates fuseki (large scale opening) moves at the
     beginning of the game. This file is undocumented but will be
     replaced by something better in the future.

   `genmove.c'   :
     This file contains `genmove()', is the routine responsible for
     generating the next move. Opening moves are generated directly in
     this file, but it calls on other modules for other moves. The
     modules called by genmove are `shapes()' (in `shapes.c'),
     `attacker()' and `defender()' (in `attdef.c'), `semeai()' (in
     `semeai.c') and `eye_finder()' (in `attdef.c'). Each module
     proposes moves, each with a value, and `genmove()' selects the one
     with the highest value.

   `hash.c'      :
     Hashing code used by for reading. (*note Hashing::)

   `hash.h'      :
     header file for hash.c.

   `liberty.h'   :
     Header file for the whole program.

   `main.c'      :
     Miscellaneous book-keeping (parsing args, signal handlers, etc.)
     sgf file interfaces (reading and writing) high level game playing
     (collecting moves from `genmove()', keeping track of passes, etc.)
     Contains very little knowledge about go : only that each side plays
     alternately, and that two passes marks the end of the game.

   `matchpat.c'  :
     This file contains `matchpat()', which looks for patterns at a
     particular board location.

   `moyo.c'      :
     This file contains code to estimate territory and influence. *Note
     Moyo::, for details.

   `reading.c'   :
     This file contains code to determine whether any given string can
     be attacked or defended. *Note Reading::, for details.

   `semeai.c'    :
     This contains `semeai()', the module which tries to win capturing
     races.

   `sethand.c'   :
     Initially populate the board with handicap stones.

   `showbord.c'  :
     This contains `showboard()', which draws an ASCII representation
     of the board, depicting dragons (stones with same letter) and
     status (color). This was the primary interface in GNU Go 1.2, but
     is now a debugging aid.

   `shapes.c'    :
     This file contains `shapes()', the module called by `genmove()'
     which tries to find moves which match a pattern. The pattern
     matcher has some sophisticated features. (*note Patterns::).
     Briefly, the pattern may take into account both friendly and
     opposing strength in the area, a string's escape potential,
     whether or not the pattern makes or breaks a valuable connection,
     whether it involves a dragon classified as dead, and it can also
     call a helper function hand tailored to the program which
     typically does some further reading to decide whether the pattern
     is appropriate.

   `optics.c'    :
     This contains the code to recognize eye shapes, documented in
     *Note Eyes::.

   `worm.c'      :
     This file contains code which is run at the beginning of each move
     cycle, before the code in `dragon.c', to determine the attributes
     of every string.

   `utils.c'     :
     An assortment of utilities, described in greater detail below.

   The directory `patterns/' contains files related to pattern matching.
Currently search for 3 types of patterns: move generation patterns (in
`patterns.db' and similar files such as hoshi.db, autogenerated from
`hoshi.sgf' *Note Patterns::, for details); eyeshape patterns (*Note
Eyes::, for `eyes.db') and connection patterns (*Note Dragon::, for
`conn.db').

   The following list contains, in addition to distributed source files
some intermediate automatically generated files such as patterns.c.
These are C source files produced by "compiling" various pattern
databases, or in some cases (such as `hoshi.db') themselves
automatically generated pattern databases produced by "compiling"
joseki files in Smart Go Format.

   `conn.db'     :
     Database of connection patterns.

   `conn.c'      :
     Automatically generated file, containing connection patterns in
     form of struct arrays, compiled by `mkpat' from `conn.db'.

   `eyes.c'      :
     Automatically generated file, containing eyeshape patterns in form
     of struct arrays, compiled by `mkpat' from `eyes.db'.

   `eyes.h'      :
     Header file for `eyes.c'.

   `eyes.db'     :
     Database of eyeshape patterns. *Note Eyes::, for details.

   `helpers.c'   :
     These are helper functions to assist in evaluating moves by
     matchpat.

   `hoshi.sgf'   :
     Smart Go Format file containing 4-4 point openings

   `hoshi.db'    :
     Automatically generated database of 4-4 point opening patterns,
     make by compiling `hoshi.sgf'

   `joseki.c'    :
     Joseki compiler, which takes a joseki file in Smart Go Format, and
     produces a pattern database.

   `komoku.sgf'  :
     Smart Go Format file containing 3-4 point openings

   `komoku.db'   :
     Automatically generated database of 3-4 point opening patterns,
     make by compiling `komoku.sgf'

   `mkeyes.c'    :
     Pattern compiler for the eyeshape databases. This program takes
     `eyes.db' as input and produces `eyes.c' as output.

   `mkpat.c'     :
     Pattern compiler for the move generation and connection databases.
     Takes the file `patterns.db' together with the autogenerated
     Joseki pattern files `hoshi.db', `komoku.db', `sansan.db',
     `mokuhadzushi.db', `takamoku.db' and produces `patterns.c', or
     takes `conn.db' and produces `conn.c'.

   `mokuhazushi.sgf' :
     Smart Go Format file containing 5-3 point openings

   `mokuhazushi.db'  :
     Pattern database compiled from mokuhadzushi.sgf

   `sansan.sgf'       :
     Smart Go Format file containing 3-3 point openings

   `sansan.db'        :
     Pattern database compiled from `sansan.sgf'

   `takamoku.sgf'     :
     Smart Go Format file containing 5-4 point openings

   `takamoku.db'      :
     Pattern database compiled from takamoku.sgf.

   `patterns.c'  :
     Pattern data, compiled from patterns.db by mkpat.

   `patterns.h'  :
     Header file relating to the pattern databases.

   `patterns.db' :
     This contains the pattern database in human readable form. See
     PATTERNS for documentation.

Utility files and routines in `engine/utils.c'
----------------------------------------------

   Only a portion of these functions are documented here. Others are
discussed elsewhere *note Utility Functions::.

   `legal()'        :
     Determines whether a move is legal.

   `trymove()'      :
     Pushes the board position on the stack, increments stackp, places
     the stone on the board if the move is legal, removes captures and
     increments stackp.

   `pushgo()'       :
     Pushes the board position on the stack and increments stackp.

   `popgo()'        :
     Pops the stack.

   `gprintf()' :
     printf-like fn (see below under TRACING)

   `TRACE', `VTRACE', `DEBUG' ()  - see below under Tracing.

   `abortgo()'  :
     Wrapper around `abort()' which dumps the stack. Usually this is
     invoked by means of the macro ASSERT (see ASSERTIONS) below.

   `utils.c' :
     Board utility functions :

   ---

   `approxlib()' :
     Counts liberties, but as an optimisation, can be given an upper
     limit, above which it can stop counting.

   `count()' :
     Low level helper for `approxlib()', but is used by other fns

   `updateboard()' :
     Place a piece on the board, remove captures, and update state
     information (for ko)


File: gnugo.info,  Node: Data Structures,  Next: Coding Styles,  Prev: Roadmap,  Up: Overview

Data structures
===============

   The most important global variable is `p[][]', which is the go board.
Each element contains `EMPTY', `WHITE' or `BLACK'.

   `stackp' is the STACK POINTER. When this is zero, `p[][]' contains
the actual board position. When `trymove()' is called, it generates a
new board position by placing a stone on the board and calling
`updateboard()'. Then `stackp' is incremented. The old position is
saved on the stack.

   Thus the value `stackp' equals the ply below the current position at
which the reading code is thinking.

   The state of the board can be saved and restored using `pushgo()'
and `popgo()'.

   `p[][]' should not be written to directly. Trial moves should be
made using trymove(), which pushes the board, places the piece, checks
the move is legal, and updates the board.  `popgo()' undoes the move.
When a move is actually made, `updateboard()' places the piece and
removes prisoners.

   `approxlib()' and `count()' can be called without actually placing a
piece. They report what the number of liberties would be if a given
piece was placed.

   Other important data structures are `dragon[][]' and `worm[][]'.
These contain information about groups of stones, whether they are
alive or dead, where they can be attacked, whether they are cutting
groups (split enemy groups), etc.

   `size', `lib', and `libi[]', `libj[]' are global variables written
to by `count()' and `approxlib()'. They return the size of the group,
and the number and positions of the liberties.

   *NOTE* : if the count is truncated because it reaches the limit on
the number of liberties, then `size' and `lib' may be smaller than the
true value.


File: gnugo.info,  Node: Coding Styles,  Prev: Data Structures,  Up: Overview

Coding styles and conventions
=============================

Tracing
-------

   A function `gprintf()' is provided. It is a cut-down `printf',
supporting only `%c', `%d', `%s', and without field widths, etc. It
does, however, add two useful facilities :

   `%m' :
     takes two parameters, and displays a formatted board co-ordinate

   indentation :
     trace messages are automatically indented to reflect the current
     stack depth, so it is clear during read-ahead when it puts a move
     down or takes one back.

   As a workaround, "outdent" `%o' at the beginning of the format
string suppresses the indentation.

   `gprintf()' is intended to be wrapped by one of the following:

   `TRACE(fmt, ...)'  :
     print the message if the 'verbose' variable > 0.  (verbose is set
     by `-t' on the command line)

   `VTRACE(fmt, ...)' :
     Verbose trace, only if `verbose' > 1 (not currently used)

   `DEBUG(flags, fmt, ...)' :
     while `TRACE' is intended to afford an overview of what GNU Go is
     considering, `DEBUG' allows occassional in depth study of a
     module, usually needed when something goes wrong. 'flags' is one
     of the `DEBUG_*' symbols in `engine/liberty.h'.  The `DEBUG' macro
     tests to see if that bit is set in the 'debug' variable, and prints
     the message if it is.  The debug variable is set using the `-d'
     command-line option.

   The variable `verbose' controls the tracing. It can equal 0 (no
trace), 1, 2, 3 or 4 for increasing levels of tracing. In practice
levels 3 and 4 should only be used when running inside `gdb' because
the volume of tracing is prohibitive. You can set the trace level at
the command line by `-t' for `verbose=1', `-t -t' for `verbose=2', etc.

Assertions
----------

   Related to tracing are assertions. Developers are strongly encouraged
to pepper their code with assertions to ensure that data structures are
as they expect. For example, the helper functions make assertions about
the contents of the board in the vicinity of the move they are
evaluating.

   `ASSERT()' is a wrapper around the standard C `assert()' function.
In addition to the test, it takes an extra pair of parameters which are
the co-ordinates of a "relevant" board position.

   If an assertion fails, the board position is included in the trace
output, and `showboard()' and `popgo()' are called to unwind and
display the stack.

Fixme
-----

   We have adopted the convention of putting the word FIXME in comments
to denote known bugs, etc.


File: gnugo.info,  Node: Analyzing,  Next: Dragon,  Prev: Overview,  Up: Top

Analyzing games stored in SGF files using GNU Go
************************************************

* Menu:

* Traces::			Analyzing traces in GNU Go 2.6
* Output File::			The Output File
* Decidestring::		Checking the reading code
* Scoring::                     Finding out the winner of the game
* Colored Display::             Colored Display


File: gnugo.info,  Node: Traces,  Next: Output File,  Prev: Analyzing,  Up: Analyzing

Interpreting Traces
===================

   A quick way to find out roughly the reason for a move is to run

     gnugo -l FILENAME -t -a -w -L MOVE NUMBER

   (You may also want to add `--quiet' to suppress the copyright
message.) In GNU Go 2.6, the weights with which each move is proposed
are listed.


File: gnugo.info,  Node: Output File,  Next: Decidestring,  Prev: Traces,  Up: Analyzing

The Output File
===============

   If GNU Go is invoked with the option `-o filename' it will produce
an output file. This option can be added at the command line in the Go
Modem Protocol Setup Window of CGoban. The output file will show the
locations of the moves considered and their weights. It is worth noting
that by enlarging the CGoban window to its fullest size it can display
3 digit numbers. Dragons with status `DEAD' are labelled with an `X',
and dragons with status `CRITICAL' are labelled with a `?'.

   Another type of SGF output file is provided by `--analyzerfile'
(*note Invoking GNU Go::).


File: gnugo.info,  Node: Decidestring,  Next: Scoring,  Prev: Output File,  Up: Analyzing

Checking the reading code
=========================

   The `--decidestring' option is used to check the reading code.  This
option takes an argument, which is a location on the board in the usual
algebraic notation (e.g. `--decidestring C17'). This will tell you
whether the reading code believes the string can be captured, and if
so, whether it believes it can be defended, which moves it finds to
attack or defend the move, how many nodes it searched in coming to
these conclusions. Note that when GNU Go runs normally (not with
`--decidestring') the points of attack and defense are cached in
`worm.attack' and `worm.defend'. Later, however, they may be moved, for
example during `shapes()' in response to a `D' pattern, so the final
points of attack and defense which are found may differ from those
found by `--decidestring'.

   If used with an output file (`-o FILENAME') `--decidestring' will
produce a variation tree showing all the variations which are
considered.


File: gnugo.info,  Node: Scoring,  Next: Colored Display,  Prev: Decidestring,  Up: Analyzing

Scoring the game
================

   GNU Go can score the game. If done at the last move, this is usually
accurate unless there is a seki. Normally GNU Go will report its
opinion about the score at the end of the game, but if you want this
information about a game stored in a file, use the `--score' option.

     gnugo --score last -l filename

   loads the sgf file and estimates the winner after the last stored
move by measuring the influence.

     gnugo --score end -l filename

   loads the sgf file and GNU Go continues to play after the last stored
move by itself up to the very end.  Then the winner is determined by
counting the territory.

     gnugo --score L10 -l filename

   loads the sgf file until a stone is placed on L10. Now the winner
will be estimated as with `gnugo --score last'.

     gnugo --score 100 -l filename

   loads the sgf file until move number 100. Now the winner will be
estimated as with `gnugo --score last'.

   If the option `-o OUTPUTFILENAME' is provided, the results will also
be written as comment at the end of the output file.

   If the option `--analyzerfile OUTPUTFILENAME' is provided, the
results will be written as comment at the end of the output file, the
result property will be set and the territory will be marked.


File: gnugo.info,  Node: Colored Display,  Prev: Scoring,  Up: Analyzing

Colored Display
===============

Dragon Display
--------------

   You can get a colored ASCII display of the board in which each dragon
is assigned a different letter; and the different `safety' values
(`ALIVE', `DEAD', `UNKNOWN', `CRITICAL') have different colors. This is
very handy for debugging.

   Save a game in sgf format using CGoban, or using the `-o' option with
GNU Go itself.

   Open an `rxvt' window. (Xterm will not work. You may also use the
Linux console.)

   Execute:

   `gnugo -l [filename] -L [movenum] -T' to get the colored display.

   The color scheme: Green = `ALIVE'; Yellow = `UNKNOWN'; White =
`DEAD' and Red = `CRITICAL'. Worms which have been amalgamated into the
same dragon are labelled with the same letter.

   Other useful colored displays may be obtained by using instead:

Eye Space Display
-----------------

   Instead of `-T', try this with `-E'. This gives a colored display of
the eyespaces, with marginal eye spaces marked `!' (*note Eyes::).

Moyo Display
------------

   The option `-m LEVEL' can give colored displays of the various
quantities which are computed in `engine/moyo.c'.

   The moyos found by GNU Go can be displayed from an rxvt window or
from the Linux console using the `-m' option. This takes a parameter:

     `-m LEVEL'
        use cumulative values for printing these debug reports :
         1 = ascii printing of territorial evaluation (5/21)
         2 = table of delta_terri values
         4 = ascii printing of moyo evaluation (5/10)
         8 = table of delta_moyo values
        16 = ascii printing of area (weak groups?) (4/0)
        32 = list of area characteristics
        64 = table of meta_connect values
       128 = trace -p fearless option (big_move priority)

   Definitions of these fields is given elsewhere (*note Moyo::).


File: gnugo.info,  Node: Dragon,  Next: Eyes,  Prev: Analyzing,  Up: Top

Worms and Dragons
*****************

* Menu:

* Worms::                             Worms
* Amalgamation::                      How two Worms are amalgamed
* Connection::                        Connections
* Half Eyes::                         Half Eyes and False Eyes
* Distance and Strategic Distance::   Distance and Strategic Distance
* Dragons::                           Union of WORMS.
* Dragons in Color::                  Colored display of DRAGONS.

   Before considering its move, GNU Go collects some data in several
arrays. Two of these arrays, called `worm' and `dragon', are discussed
in this document. Others are discussed in *Note Eyes::.

   This information is intended to help evaluate the connectedness, eye
shape, escape potential and life status of each group.

   Later routines called by `genmove()' will then have access to this
information. This document attempts to explain the philosophy and
algorithms of this preliminary analysis, which is carried out by the
two routines `make_worm()' and `make_dragon()' in `dragon.c'.

   In this document wherever we define a concept we use CAPITAL LETTERS
for the term being defined.

   A WORM is a maximal set of vertices on the board which are connected
along the horizontal and vertical lines, and are of the same color,
which can be BLACK, WHITE or EMPTY. The term EMPTY applied to a worm
means that the worm consists of empty (unoccupied) vertices. It does
NOT mean that that the worm is the empty set. A STRING is a nonempty
worm. An empty worm is called a CAVITY.  If a subset of vertices is
contained in a worm, there is a unique worm containing it; this is its
WORM CLOSURE.

   A DRAGON is a union of strings of the same color which will be
treated as a unit. The dragons are generated anew at each move. If two
strings are in the dragon, it is the computer's working hypothesis that
they will live or die together and are effectively connected.

   The purpose of the dragon code is to allow the computer to formulate
meaningful statements about life and death.  To give one example,
consider the following situation:

           OOOOO
          OOXXXOO
          OX...XO
          OXXXXXO
           OOOOO

   The X's here should be considered a single group with one three-space
eye, but they consist of two separate strings.  Thus we must amalgamate
these two strings into a single dragon. Then the assertion makes sense,
that playing at the center will kill or save the dragon, and is a vital
point for both players. It would be difficult to formulate this
statement if the X's are not perceived as a unit.

   The present implementation of the dragon code involve simplifying
assumptions which can be refined in later implementations.


File: gnugo.info,  Node: Worms,  Next: Amalgamation,  Prev: Dragon,  Up: Dragon

Worms
=====

   The array `struct worm_data worm[19][19]' collects information about
the worms. We will give definitions of the various fields. Each field
has constant value at each vertex of the worm. We will define each
field.


     struct worm_data {
     {
       int color;
       int size;
       float effective_size;
       int origini;
       int originj;
       int liberties;
       int liberties2;
       int liberties3;
       int liberties4;
       int attacki;
       int attackj;
       int attack_code;
       int lunchi;
       int lunchj;
       int defendi;
       int defendj;
       int defend_code;
       int cutstone;
       int cutstone2;
       int genus;
       int value;
       int ko;
       int inessential;
     };

   COLOR: If the worm is `BLACK' or `WHITE', that is its color.
Cavities (empty worms) have an additional attribute which we call
BORDERCOLOR. This will be one of `BLACK_BORDER,' `WHITE_BORDER' or
`GRAY_BORDER'. Specifically, if all the worms adjacent to a given empty
worm have the same color (black or white) then we define that to be the
bordercolor. Otherwise the bordercolor is gray.

   Rather than define a new field, we keep this data in the field
color. Thus for every worm, the color field will have one of the
following values: `BLACK', `WHITE', `GRAY_BORDER', `BLACK_BORDER' or
`WHITE_BORDER'.  The last three categories are empty worms classified
by bordercolor.

   SIZE: This field contains the cardinality of the worm.

   ORIGIN: Each worm has a distinguished member, called its ORIGIN. Its
coordinates are `(origini, originj)'. The purpose of this field is to
make it easy to determine when two vertices lie in the same worm: we
compare their origin. Also if we wish to perform some test once for
each worm, we simply perform it at the origin and ignore the other
vertices. The origin is characterized by the test:

     (worm[m][n].origini == m) && (worm[m][n].originj == n).

   LIBERTIES:      For a nonempty worm the field liberties is the
number of liberties of the string. This is supplemented by LIBERTIES2,
LIBERTIES3 and LIBERTIES4, which are the number of second order, third
order and fourth order liberties, respectively.

   The definition of liberties of order >1 is adapted to the problem of
detecting the shape of the surrounding cavity. In particular we want to
be able to see if a group is loosely surrounded. A LIBERTY OF ORDER n
is an empty vertex which may be connected to the string by placing n
stones of the same color on the board, but no fewer. The path of
connection may pass through an intervening group of the same color. The
stones placed at distance >1 may not touch a group of the opposite
color. Connections through ko are not permitted. Thus in the following
configuration:

               .XX...    We label the     .XX.4.
               XO....    liberties of     XO1234
               XO....    order < 5 of     XO1234
               ......    the O group:     ..2.4.
               .X.X..                     .X.X..

   The convention that liberties of order >1 may not touch a group of
the opposite color means that knight's moves and one space jumps are
perceived as impenetrable barriers.  This is useful in determining when
the string is becoming surrounded.

   We say that n is the DISTANCE of the liberty of order n from the
dragon.

   ATTACK: If it is determined that the string may be easily captured,
`(attacki, attackj)' points to an attacking move. In the present
implementation, this is only used for strings with <4 liberties. The
algorithm in `reading.c' is fairly reliable at finding ladders but poor
at finding nets (geta). This module therefore needs rewriting. If no
attacking move is found, then `attacki == -1'.

   ATTACK_CODE: 1 if the worm can be captured unconditionally, 2 or 3
if it can be captured with ko.  If can be captured provided the
attacker is willing to ignore any ko threat, then the `attack_code ==
2'.  If it can be captured provided the attacker can come up with a
sufficiently large ko threat, then the `attack_code == 3'.

   LUNCH:  If `lunchi != -1' then `(lunchi, lunchj)' points to a
boundary worm which can be easily captured.  (It does not matter
whether or not the string can be defended.)

   DEFEND: If there is an attack on the string (stored in the ATTACK
field defined above), and there is a move which defends the string,
this move is stored in `(defendi, defendj)'.  Otherwise `defendi == -1'.

   DEFEND_CODE: 1 if the worm can be defended unconditionally, 2 or 3
if it can be defended with ko.  If can be defended provided the
defender is willing to ignore any ko threat, then the `defend_code ==
2'.  If it can be captured provided the defender can come up with a
sufficiently large ko threat, then the `defend_code == 3'.

   CUTSTONE: This field is equal to 2 for cutting stones, 1 for
potential cutting stones. Otherwise it is zero.  Definitions for this
field:

   A CUTTING STONE is one adjacent to two enemy strings, which do not
have a liberty in common. The most common type of cutting string is in
this situation.


               XO
               OX

   A POTENTIAL CUTTING STONE is adjacent to two enemy strings which do
share a liberty. For example, X in:


               XO
               O.

   For cutting strings we set `worm[m][n].cutstone=2'. For potential
cutting strings we set `worm[m][n].cutstone=1'.

   GENUS: There are two separate notions of genus for worms and
dragons. The dragon notion is more important, so `dragon[m][n].genus'
is a far more useful field than `worm[m][n].genus'. Both fields are
intended as approximations to the number of eyes. The GENUS of a string
is the number of connected components of its complement, minus one. It
is an approximation to the number of eyes of the string.

   VALUE: A measure of the value of the worm.

   KO: For every ko, the flag `ko' is set to 1 at the ko stone which is
in atari, and also at the ko cavity adjacent to it. Thus in this
situation:


                  XO
                 X.XO
                  XO

   the flag `ko' is set to 1 at the rightmost X stone, and also at the
cavity to its left.

   INESSENTIAL: An INESSENTIAL string is one which meets a criterion
designed to guarantee that it has no life potential unless a particular
surrounding string of the opposite color can be killed. More precisely
an INESSENTIAL STRING is a string S of genus zero, not adjacent to any
opponent string which can be easily captured, and which has no edge
liberties or second order liberties, and which satisfies the following
further property: If the string is removed from the board, then the
empty worm E which is the worm closure of the set of vertices which it
occupied has bordercolor the opposite of the removed string. The empty
worm E (empty, that is, as a worm of the board modified by removal of
S) consists of the union of support of S together with certain other
empty worms which we call the BOUNDARY COMPONENTS of S.

   The inessential strings are used in the amalgamation of cavities in
make_dragon.

   The function `makeworms()' will generate data for all worms. For
empty worms, the following fields are significant: `color', `size',
`origini' and `originj'. The `liberty', `attack', `defend', `cutstone',
`genus' and `inessential' fields have significance only for nonempty
worms.


File: gnugo.info,  Node: Amalgamation,  Next: Connection,  Prev: Worms,  Up: Dragon

Amalgamation
============

   A DRAGON, we have said, is a group of stones which are treated as a
unit. It is a working hypothesis that these stones will live or die
together. Thus the program will not expect to disconnect an opponent's
strings if they have been amalgamated into a single dragon.

   The function `makedragons()' will amalgamate worms into dragons by
maintaining separate arrays `worms[]' and `dragons[]' containing
similar data. Each dragon is a union of worms. Just as the data
maintained in `worm[19][19]' is constant on each worm, the data in
`dragon[19][19]' is constant on each dragon.

   AMALGAMATION of two worms means means in practice replacing the
origin of one worm by the origin of the other.  Amalgamation takes
place in two stages: first, the amalgamation of empty worms (cavities)
into empty dragons (caves); then, the amalgamation of colored worm into
dragons.

Amalgamation of cavities
========================

   As we have already defined it, a CAVITY is an empty worm. A CAVE is
an empty dragon.

   Under certain circumstances we want to amalgamate two or more
cavities into a single cave. This is done before we amalgamate strings.
An example where we wish to amalgamate two empty strings is the
following:


           OOOOO
          OOXXXOO
          OXaObXO
          OOXXXOO
           OOOOO

   The two empty worms at a and b are to be amalgamated.

   We have already defined a string to be INESSENTIAL if it meets a
criterion designed to guarantee that it has no life potential unless a
particular surrounding string of the opposite color can be killed. An
INESSENTIAL STRING is a string S of genus zero which is not a cutting
string or potential cutting string, and which has no edge liberties or
second order liberties (the last condition should be relaxed), and
which satisfies the following further property: If the string is
removed from the board, then the empty worm E which is the worm closure
of the set of vertices which it occupied has bordercolor the opposite
of the removed string.

   Thus in the previous example, after removing the inessential string
at the center the worm closure of the center vertex consists of an empty
worm of size 3 including a and b. The latter are the boundary
components.

   The last condition in the definition of inessential worms excludes
examples such as this:


             OOOO
            OXXOO
           OXX.XO
           OX.XXO
           OOXXO
            OOO

   Neither of the two X strings should be considered inessential
(together they form a live group!) and indeed after removing one of
them the resulting space has gray bordercolor, so by this definition
these worms are not inessential.

   Some strings which should by rights be considered inessential will be
missed by this criterion.

   The algorithm for amalgamation of empty worms consists of
amalgamating the boundary components of any inessential worm. The
resulting dragon has bordercolor the opposite of the removed string.

   Any dragon consisting of a single cavity has bordercolor equal to
that of the cavity.

Amalgamation of strings
=======================

   Amalgamation of nonempty worms in GNU Go 2.6 proceeds as follows.
First we amalgamate all boundary components of an eyeshape. Thus in the
following example:


     .OOOO.       The four X strings are amalgamated into a
     OOXXO.       single dragon because they are the boundary
     OX..XO       components of a blackbordered cave. The
     OX..XO       cave could contain an inessential string
     OOXXO.       with no effect on this amalgamation.
     XXX...

   The code for this type of amalgamation is in the routine
`dragon_eye()', discussed further in EYES.

   Next, we amalgamate strings which seem uncuttable. We amalgamate
dragons which either share two or more common liberties, or share one
liberty into the which the opponent cannot play without being captured.
(ignores ko rule).


        X.    X.X     XXXX.XXX         X.O
        .X    X.X     X......X         X.X
                      XXXXXX.X         OXX

   A database of connection patterns may be found in `patterns/conn.db'.


File: gnugo.info,  Node: Connection,  Next: Half Eyes,  Prev: Amalgamation,  Up: Dragon

Connection
==========

   The fields `black_eye.cut' and `white_eye.cut' are set where the
opponent can cut, and this is done by the B (break) class patterns in
`conn.db'.  There are two important uses for this field, which can be
accessed by the autohelper functions `xcut()' and `ocut()'. The first
use is to stop amalgamation in positions like


     ..X..
     OO*OO
     X.O.X
     ..O..

   where X can play at * to cut off either branch. What happens here is
that first connection pattern 6 finds the double cut and marks * as a
cutting point. Later the C (connection) class patterns in conn.db are
searched to find secure connections over which to amalgamate dragons.
Normally a diagonal connection would be deemed secure and amalgamated
by connection pattern 3, but there is a constraint requiring that
neither of the empty intersections is a cutting point.

   This is far from perfect. It would be better to amalgamate in either
direction, preferably leaving the smallest part as a tail to save or
sacrifice.

   The other use is to simplify making alternative connection patterns
to the solid connection. Positions where the diag_miai helper thinks a
connection is necessary are marked as cutting points by connection
pattern 12. Thus we can write a connection pattern like `CC23c':


     ?xx?
     XO*?               straight extension to connect
     O..?
     
     :8,90,0,C,5,5,0,2,2,NULL
     
     ?xx?
     XOb?
     Oa.?
     
     ;xcut(a) && odefend_against(b,a)

   where we verify that a move at `*' would stop the enemy from safely
playing at the cutting point, thus defending against the cut.


File: gnugo.info,  Node: Half Eyes,  Next: Distance and Strategic Distance,  Prev: Connection,  Up: Dragon

Half Eyes and False Eyes
========================

   A HALF EYE is a place where, if the defender plays first, and eye
will materialize, but where if the attacker plays first, no eye will
materialize. A FALSE EYE is a vertex which is surrounded by a dragon
yet is not an eye. Here is a half eye:


     XXXXX
     OO..X
     O.O.X
     OOXXX

   Here is a false eye:


     XXXXX
     XOO.X
     O.O.X
     OOXXX

   The "topological" algorithm for determining half and false eyes is
described elsewhere (*note Eye Topology::).

   The half eye data is collected in the dragon array. Before this is
done, however, an auxiliary array called half_eye_data is filled with
information. The type is 0, or else HALF_EYE or FALSE_EYE depending on
which type is found; and `(ki, kj)' points to a move to kill the half
eye.


     struct half_eye_data half_eye[19][19];
     
     struct half_eye_data {
       int type;         /* HALF_EYE or FALSE_EYE; */
       int ki;           /* (ki,kj) is the move to kill or live */
       int kj;
     };

   The arrays `half_eye[19][19]', `half_eyei[19][19]' and
`half_eyej[19][19]' are filled. First, `half_eye[m][n]' is zero unless
a half eye or false eye is found at the empty vertex `(m,n)'; in this
case, it is assigned the value `FALSE_EYE' or `HALF_EYE', and
(`half_eyei[m][n]', `half_eyej[m][n]') points to the dragon having the
false or half eye.


File: gnugo.info,  Node: Distance and Strategic Distance,  Next: Dragons,  Prev: Half Eyes,  Up: Dragon

Distance and Strategic Distance
===============================

   The DISTANCE from an empty vertex to black is the length of the
shortest path from the vertex to any black stone, not passing through a
white stone. The STRATEGIC DISTANCE is defined similarly except that
the path may not pass through any liberty of any white stone, except
possibly at the beginning. The distance or strategic distance is -1
(representating infinity) if no such path may be found.  Distance and
strategic distance to white are defined similarly.

   For example in the following diagram on the edge, the distance from
the vertex at `a' to the color `X' is six:


     ...........
     ..X.XXOOO...
     ...XOO.a.OO
     ...........
     -----------

   because we can find the following path of length 6 from `a' to `X':


     ...........
     ..X.XXOOO...
     ...6OO1a.OO
     ...5432....
     -----------

   The strategic distance is infinite, however. The above path is not
admissible for strategic distance, because at 3 and 4 it passes through
`O''s liberties. The path at 1 also is an `O' liberty but this is
admissible since it is at the very beginning of the path.

   We maintain these data in the arrays `distance_to_black[19][19]' and
`distance_to_white[19][19]', and similarly for the strategic_distance.
They may also be accessed by the functions `distance_to()' and
`strategic_distance_to()' in `utils.c'.


File: gnugo.info,  Node: Dragons,  Next: Dragons in Color,  Prev: Distance and Strategic Distance,  Up: Dragon

Dragons
=======

   The array `struct dragon_data dragon[19][19]' collects information
about the dragons. We will give definitions of the various fields. Each
field has constant value at each vertex of the dragon. We will define
each field.


     struct dragon_data {
       int color;
       int origini;
       int originj;
       int borderi;
       int borderj;
       int size;
       float effective_size;
       int heyes;
       int heyei;
       int heyej;
       int genus;
       int escape_route;
       int escape2;
       int lunchi;
       int lunchj;
       int status;
       int safety;
       int vitality;
       int semeai;
     };

   COLOR: For strings, this is `BLACK' or `WHITE'.  For caves, it is
`BLACK_BORDER', `WHITE_BORDER' or `GRAY_BORDER'. The meaning of these
concepts is the same as for worms.

   ORIGIN: The origin of the dragon is a unique particular vertex of
the dragon, useful for determining when two vertices belong to the same
dragon. Before amalgamation the worm origins are copied to the dragon
origins. Amalgamation of two dragons amounts to changing the origin of
one.

   BORDER: This field is relevant for caves. If the color of the cave
is `BLACK_BORDER' or `WHITE_BORDER' then the surrounding worms all have
the same color `BLACK' or `WHITE' and these have been amalgamated into
a dragon with origin `(borderi, borderj)'.

   SIZE: This is the cardinality of the dragon.

   HEYES: This is the number of half eyes the dragon has. A HALF EYE is
a pattern where an eye may or may not materialize, depending on who
moves first. If any half eyes are found, `(heyi,heyj)' points to a move
which will create an eye.

   GENUS: The GENUS of a nonempty dragon consists of the number of
distinct adjacent caves whose bordercolor is the color of the dragon,
minus the number of false eyes found. The genus is a computable
approximation to the number of eyes a dragon has.

   VALUE: A measure of the value of the dragon.

   ESCAPE ROUTE: The field `dragon[m][n].escape_route' is the maximum
value of `worm[i][j].liberties4' over the worms of the dragon.  This is
a measure of the escape potential of the string.

   LUNCH: If `lunchi != -1', then `(lunchi, lunchj)' points to a
boundary worm which can be captured easily. In contrast with the worm
version of this parameter, we exclude strings which cannot be saved.

   STATUS: An attempt is made to classify the dragons as `ALIVE',
`DEAD', `CRITICAL' or `UNKNOWN'. The `CRITICAL' classification means
that the fate of the dragon depends on who moves first in the area. The
exact definition is in the function `dragon_status()'. If the dragon is
found to be surrounded, the status is `DEAD' if it has less than 1.5
eyes or if the reading code determines that it can be killed, `ALIVE'
if it has 2 or more eyes, and `CRITICAL' if it has 1.5 eyes. A lunch
generally counts as a half eye in these calculations. If it has less
than 2 eyes but seems possibly able to escape, the status may be
`UNKNOWN'.

   It is of the utmost importance accomplish this classification as
accurately as possible. Unfortunately this is not easy.  A problem is
that the algorithm described is that it occasionally classifies dragons
as DEAD which can actually form two eyes.

   SAFETY: This is a field similar to `status' but more useful for some
purposes. In `moyo.c' there is a heuristic test for weakness based on
the influence of surrounding dragons. The safety field is the same as
the status unless the status is `UNKNOWN'. If the status is `UNKNOWN'
then `dragon.safety' is set to `CRITICAL' if it is found to be weak by
the algorithm in `moyo.c'.

   VITALITY: A measure of the life potential of the dragon, used in
`semeai()'.

   SEMEAI: true if the dragon is involved in a semeai (capturing race).


File: gnugo.info,  Node: Dragons in Color,  Prev: Dragons,  Up: Dragon

Colored display
===============

   You can get a colored ASCII display of the board in which each dragon
is assigned a different letter; and the different `safety' values
(`ALIVE', `DEAD', `UNKNOWN', `CRITICAL') have different colors. This is
very handy for debugging.

   Save a game in sgf format using CGoban, or using the `-o' option with
GNU Go itself.

   Open an `rxvt' window. (Xterm will not work. You may also use the
Linux console.)

   Execute:

   `gnugo -l [filename] -L [movenum] -T' to get the colored display.

   The color scheme: Green = `ALIVE'; Yellow = `UNKNOWN'; White =
`DEAD' and Red = `CRITICAL'. Worms which have been amalgamated into the
same dragon are labelled with the same letter.

   Other useful colored displays may be obtained by using instead:

   * the option -E to display eye spaces (*note Eyes::).

   * the option -m 1 to display territory (*note Moyo::).

   The colored displays are documented elsewhere (*note Colored
Display::).


File: gnugo.info,  Node: Eyes,  Next: Moyo,  Prev: Dragon,  Up: Top

Eyes and Half Eyes
******************

   The purpose of this document is to describe the algorithm used in
GNU Go 2.6 to determine eyes.

* Menu:

* Local Games::                 Local games
* Eye Space::                   Eye space
* Eye Space as Local Game::     Eye space as local game
* Eye Example::                 An example
* Graphs::                      Underlying graphs
* Eye Shape::                   Pattern matching
* Eye Topology::                False eyes and half eyes

