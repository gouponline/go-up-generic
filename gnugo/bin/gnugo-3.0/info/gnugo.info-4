This is gnugo.info, produced by makeinfo version 4.0 from gnugo.texi.

INFO-DIR-SECTION GNU games
START-INFO-DIR-ENTRY
* GNU go: (gnugo).          The GNU Go program
END-INFO-DIR-ENTRY


File: gnugo.info,  Node: Threats to Attack or Defend,  Next: Non-Working Moves,  Prev: Attack and Defense,  Up: MG Details

Threats to Attack or Defend
---------------------------

   A threat to attack a worm, but where the worm can be defended is
used as a secondary move reason.  This move reason can enhance the
value of a move so that it becomes sente.  A threatening move without
any other justification can also be used as a ko threat.  The same is
true for a move that threatens defense of a worm, but where the worm
can still be captured if the attacker doesn't tenuki.

   Threats found by the owl code are called *owl threats* and they have
their own owl reasons.


File: gnugo.info,  Node: Non-Working Moves,  Next: Multi Attack or Defense,  Prev: Threats to Attack or Defend,  Up: MG Details

Not working attack and defense moves
------------------------------------

   The tactical reading may come up with ineffective attacks or defenses
occasionally. When these can be detected by patterns, it's possible to
cancel the attack and/or defense potential of the moves by using these
move reasons. This can only be done by action lines in the patterns.


File: gnugo.info,  Node: Multi Attack or Defense,  Next: Cutting and Connecting,  Prev: Non-Working Moves,  Up: MG Details

Multiple attack or defense moves
--------------------------------

   Sometimes a move attacks at least one of a number of worms or
simultaneously defends all of several worms. These moves are noted by
their own move reasons.


File: gnugo.info,  Node: Cutting and Connecting,  Next: Semeai,  Prev: Multi Attack or Defense,  Up: MG Details

Cutting and connecting moves
----------------------------

   Moves which connect two distinct dragons are called `connecting
moves'.  Moves which prevent such connections are called "cutting
moves". Cutting and connecting moves are primarily found by pattern
matching, the `C' and `B' class patterns.

   A second source of cutting and connecting moves comes from the attack
and defense of cutting stones. A move which attacks a worm
automatically counts as a connecting move if there are multiple dragons
adjacent to the attacked worm. Similarly a defending move counts as a
cutting move. The action taken when a pattern of this type is found is
to induce a connect or cut move reason.

   When a cut or connect move reason is registered, the involved dragons
are of course stored. Thus the same move may cut and/or connect several
pairs of dragons.


File: gnugo.info,  Node: Semeai,  Next: Making eyes,  Prev: Cutting and Connecting,  Up: MG Details

Semeai winning moves
--------------------

   A move which is necessary to win a capturing race is called a "semeai
move". These are similar to attacking moves, except that they involve
the simultaneous attack of one worm and the defense of another. As for
attack and defense moves, it's important that all moves which win a
semeai are found, so an informed choice can be made between them.

   Semeai move reasons should be set by the semeai module. However this
has not been implemented yet. One might also wish to list moves which
increase the lead in a semeai race (removes ko threats) for use as
secondary move reasons. Analogously if we are behind in the race.


File: gnugo.info,  Node: Making eyes,  Next: Antisuji moves,  Prev: Semeai,  Up: MG Details

Making or destroying eyes
-------------------------

   A move which makes a difference in the number of eyes produced from
an eye space is called an "eye move". It's not necessary that the eye is
critical for the life and death of the dragon in question, although it
will be valued substantially higher if this is the case. As usual it's
important to find all moves that change the eye count.

   (This is part of what eye_finder was doing. Currently it only finds
one vital point for each unstable eye space.)


File: gnugo.info,  Node: Antisuji moves,  Next: Territorial moves,  Prev: Making eyes,  Up: MG Details

Antisuji moves
--------------

   Moves which are locally inferior or for some other reason must not be
played are called "antisuji moves". These moves are generated by pattern
matching. Care must be taken with this move reason as the move under no
circumstances will be played.


File: gnugo.info,  Node: Territorial moves,  Next: Owl attack and defense,  Prev: Antisuji moves,  Up: MG Details

Territorial moves
-----------------

   Any move that increases territory gets a move reason. These are the
block territory and expand territory move reasons. Such move reasons
are added by the `b' and `e' patterns in `patterns/patterns.db'.
Similarly the `E' patterns attempt to generate or mitigate an moyo,
which is a region of influence not yet secure territory, yet valuable.
Such a pattern sets the "expand moyo" move reason.


File: gnugo.info,  Node: Owl attack and defense,  Next: Combination Attacks,  Prev: Territorial moves,  Up: MG Details

Attacking and Defending Dragons
-------------------------------

   Just as the tactical reading code tries to determine when a worm can
be attacked or defended, the owl code tries to determine when a dragon
can get two eyes and live. The function `owl_reasons()' generates the
corresponding move reasons.

   The owl attack and owl defense move reasons are self explanatory.

   The owl attack threat reason is generated if owl attack on an
opponent's dragon fails but the owl code determines that the dragon can
be killed with two consecutive moves. The killing moves are stored in
`(dragon[ai][aj].owl_attacki_i, dragon[ai][aj].owl_attacki_j)' and
`(dragon[ai][aj].owl_second_attacki_i,
dragon[ai][aj].owl_second_attacki_j)'.

   Similarly if a friendly dragon is dead but two moves can revive it,
an owl defense threat move reason is generated.

   The prevent threat reasons are similar but with the colors reversed:
if the opponent has an attack threat move then a move which removes the
threat gets a prevent threat move reason.

   The owl uncertain move reasons are generated when the owl code runs
out of nodes. In order to prevent the owl code from running too long, a
cap is put on the number of nodes one owl read can generate. If this is
exceeded, the reading is cut short and the result is cached as usual,
but marked uncertain.  In this case an owl uncertain move reason may be
generated.  For example, if the owl code finds the dragon alive but is
unsure, a move to defend may still be generated.


File: gnugo.info,  Node: Combination Attacks,  Prev: Owl attack and defense,  Up: MG Details

Combination Attacks
-------------------

   The function `atari_atari' tries to find a sequence of ataris
culminating in an unexpected change of status of any opponent string,
from ALIVE to CRITICAL, or from CRITICAL to DEAD. Once such a sequence
of ataris is found, it tries to shorten it by rejecting irrelevant
moves.


File: gnugo.info,  Node: Valuation,  Next: Move Generation Functions,  Prev: MG Details,  Up: Move Generation

Valuation of suggested moves
============================

   Moves are valued with respect to five different criteria. These are

   * territorial value

   * influence value

   * strategical value

   * shape value,

   * secondary value.

   All of these are floats and should be measured in terms of actual
points.

   Territorial value is the amount of secure territory generated (or
saved) by the move. Attack and defense moves have territorial values
given by twice the number of stones in the worm plus adjacent empty
space. This value is in practice approximated from the "effective size"
measure.

   Influence value is an estimation of the move's effect on the size of
potential territory and possibly "area". This is currently implemented
by using delta_moyo_simple(). This can probably be improved quite a
bit. If the move captures some stones, this fact should be taken into
account when computing moyo/area.

   Strategical value is a measure of the effect the move has on the
safety of all groups on the board. Typically cutting and connecting
moves have their main value here. Also edge extensions, enclosing moves
and moves towards the center have high strategical value. The
strategical value should be the sum of a fraction of the territorial
value of the involved dragons. The fraction is determined by the change
in safety of the dragon.

   Shape value is a purely local shape analysis, which primarily is
intended to choose between moves having the same set of reasons. An
important role of this measure is to offset mistakes made by the
estimation of territorial and influence values. In open positions it's
often worth sacrificing a few points of (apparent) immediate profit to
make good shape. Shape value is implemented by pattern matching, the
Shape patterns.

   Secondary value is given for move reasons which by themselves are not
sufficient to play the move. One example is to reduce the number of
eyes for a dragon that has several or to attack a defenseless worm.

   When all these values have been computed, they are summed, possibly
weighted (secondary value should definitely have a small weight), into
a final move value. This value is used to decide the move.

* Menu:

* Territorial value::		  How much territory does a move gain
* Influence value::		  How much influence does a move gain
* Strategical value::             Strategical gains from a move
* Shape factor::		  Local shape
* Minimum Value::                 Minimum value
* Secondary Value::               Other, more indirect, gains from a move
* Threats and Followup Value::    Valuation of attack and defense threats


File: gnugo.info,  Node: Territorial value,  Next: Influence value,  Up: Valuation

Territorial Value
-----------------

   The algorithm for computing territorial value is in the function
`estimate_territorial_value'. As the name suggests, it seeks to
estimate the amount the move adds to secure territory.

   This function examines every reason for the move and takes into
account the safety of different dragons. For example if the reason for
the move is that it attacks and kills a worm, no value is assigned if
the worm is already DEAD. If the worm is not DEAD the value of the move
is twice the effective size of the worm.

   In addition to such additions to territory, if the move is found to
be a block or expanding move, the function `influence_delta_territory'
is consulted to find areas where after the move the influence function
becomes so strong that these are counted as secure territory, or where
the influence function is sufficiently weakened that these are removed
from the secure territory of the opponent (*note Influential
Functions::).


File: gnugo.info,  Node: Influence value,  Next: Strategical value,  Prev: Territorial value,  Up: Valuation

Influence Value
---------------

   The function `estimate_influence_value' attempts to assign a value
to the influence a move. The functions `influence_delta_strict_moyo'
`influence_delta_strict_area' are called to find areas where after the
move the influence function becomes strong enough that these are
counted as friendly moyo or area, or which are taken away from the
opponent's moyo or area (*note Influential Functions::).


File: gnugo.info,  Node: Strategical value,  Next: Shape factor,  Prev: Influence value,  Up: Valuation

Strategical Value
-----------------

   Strategical defense or attack reasons are assigned to any move which
matches a pattern of type `a' or `d'. These are moves which in some
(often intangible) way tend to help strengthen or weaken a dragon. Of
course strengthening a dragon which is already alive should not be
given much value, but when the move reason is generated it is not
necessary to check its status or safety. This is done later, during the
valuation phase.


File: gnugo.info,  Node: Shape factor,  Next: Minimum Value,  Prev: Strategical value,  Up: Valuation

Shape Factor
------------

   In the value field of a pattern (*note Pattern Values::) one may
specify a shape value.

   This is used to compute the shape factor, which multiplies the score
of a move. We take the largest positive contribution to shape and add 1
for each additional positive contribution found.  Then we take the
largest negative contribution to shape, and add 1 for each additional
negative contribution. The resulting number is raised to the power 1.05
to obtain the shape factor.

   The rationale behind this complicated scheme is that every shape
point is very significant. If two shape contributions with values (say)
5 and 3 are found, the second contribution should be devalued to 1.
Otherwise the engine is too difficult to tune since finding multiple
contributions to shape can cause significant overvaluing of a move.


File: gnugo.info,  Node: Minimum Value,  Next: Secondary Value,  Prev: Shape factor,  Up: Valuation

Minimum Value
-------------

   A pattern may assign a minimum (and sometimes also a maximum) value.
For example the Joseki patterns have values which are prescribed in
this way, or ones with a `value' field.  One prefers not to use this
approach but in practice it is sometimes needed.


File: gnugo.info,  Node: Secondary Value,  Next: Threats and Followup Value,  Prev: Minimum Value,  Up: Valuation

Secondary Value
---------------

   Secondary move reasons are weighed very slightly. Such a move can
tip the scales if all other factors are equal.


File: gnugo.info,  Node: Threats and Followup Value,  Prev: Secondary Value,  Up: Valuation

   Followup value refers to value which may acrue if we get two moves
in a row in a local area. It is assigned by the function
`add_followup_value', for example through the `followup_value'
autohelper macro.

   Attack and defense threats, including owl threats are usually given
a small amount of weight, as is followup value.

   If the largest move on the board is a ko which we cannot legally
take, then such a move becomes attractive as a ko threat and the
followup value or the value of the threat are taken in full.


File: gnugo.info,  Node: Move Generation Functions,  Next: Local MG Functions,  Prev: Valuation,  Up: Move Generation

Move Generation Functions
=========================

   The following functions are defined in `move_reasons.c'.

   * `void clear_move_reasons(void)'
          Initialize move reason data structures.

   * `void add_lunch(int ai, int aj, int bi, int bj)'
          See if a lunch is already in the list of lunches, otherwise
          add a new entry. A lunch is in this context a pair of eater
          (a dragon) and food (a worm).

   * `void remove_lunch(int ai, int aj, int bi, int bj)'
          Remove a lunch from the list of lunches.

   * `void add_defense_move(int ti, int tj, int ai, int aj)'
          Add to the reasons for the move at (ti, tj) that it defends
          the worm at (ai, aj).

   * `int defense_move_known(int ti, int tj, int ai, int aj)'
          Query whether a defense move is already known.  Add to the
          reasons for the move at (ti, tj) that it attacks the worm at
          (ai, aj).

   * `int attack_move_known(int ti, int tj, int ai, int aj)'
          Query whether an attack move is already known.

   * `void remove_defense_move(int ti, int tj, int ai, int aj)'
          Remove from the reasons for the move at (ti, tj) that it
          defends the worm at (ai, aj). We do this by adding a
          NON_DEFEND move reason and wait until later to actually
          remove it. Otherwise it may be added again. We must also
          check that there do exist a defense move reason for this
          worm. Otherwise we may end up in an infinite loop when trying
          to actually remove it.

   * `void remove_attack_move(int ti, int tj, int ai, int aj)'
          Remove from the reasons for the move at (ti, tj) that it
          attacks the worm at (ai, aj). We do this by adding a
          NON_ATTACK move reason and wait until later to actually
          remove it. Otherwise it may be added again.

   * `void add_connection_move(int ti, int tj, int ai, int aj, int bi,
     int bj)'
          Add to the reasons for the move at (ti, tj) that it connects
          the dragons at (ai, aj) and (bi, bj). Require that the
          dragons are distinct.

   * `void add_cut_move(int ti, int tj, int ai, int aj, int bi, int bj)'
          Add to the reasons for the move at (ti, tj) that it cuts the
          dragons at (ai, aj) and (bi, bj). Require that the dragons are
          distinct.

   * `void add_antisuji_move(int ti, int tj)'
          Add to the reasons for the move at (ti, tj) that it is an
          anti-suji.  This means that it's a locally inferior move or
          for some other reason must *not* be played.

   * `void add_semeai_move(int ti, int tj, int ai, int aj, int bi, int
     bj)'
          Add to the reasons for the move at (ti, tj) that it wins a
          semeai between my worm at (ai, aj) and your worm at (bi, bj).

   * `void add_vital_eye_move(int ti, int tj, int ai, int aj, int
     color)'
          Add to the reasons for the move at (ti, tj) that it's the
          vital point for the eye space at (ai, aj) of color color.

   * `void add_attack_either_move(int ti, int tj, int ai, int aj, int
     bi, int bj)'
          Add to the reasons for the move at (ti, tj) that it attacks
          either (ai, aj) or (bi, bj) (e.g. a double atari). This move
          reason is only used for double attacks on opponent stones.
          Before accepting the move reason, check that the worms are
          distinct and that neither is undefendable.

   * `void add_defend_both_move(int ti, int tj, int ai, int aj, int bi,
     int bj)'
          Add to the reasons for the move at (ti, tj) that it defends
          both (ai, aj) and (bi, bj) (e.g. from a double atari). This
          move reason is only used for defense of own stones.

   * `void add_block_territory_move(int ti, int tj)'
          Add to the reasons for the move at (ti, tj) that it secures
          territory by blocking.

   * `void add_expand_territory_move(int ti, int tj)'
          Add to the reasons for the move at (ti, tj) that it expands
          territory.

   * `void add_expand_moyo_move(int ti, int tj)'
          Add to the reasons for the move at (ti, tj) that it expands
          moyo.

   * `void add_shape_value(int ti, int tj, float value)'
          Increase or decrease the shape value for the move at (ti, tj).

   * `void add_strategical_attack_move(int ti, int tj, int ai, int aj)'
          Add to the reasons for the move at (ti, tj) that it attacks
          the dragon (ai, aj) on a strategical level.

   * `void add_strategical_defense_move(int ti, int tj, int ai, int aj)'
          Add to the reasons for the move at (ti, tj) that it defends
          the dragon (ai, aj) on a strategical level.

   * `void add_followup_value(int ti, int tj, float value)'
          Add value of followup moves.

   * `void set_minimum_move_value(int ti, int tj, float value)'
          Set a minimum allowed value for the move.

   * `void set_maximum_move_value(int ti, int tj, float value)'
          Set a maximum allowed value for the move.

   * `void set_minimum_territorial_value(int ti, int tj, float value)'
          Set a minimum allowed territorial value for the move.

   * `void set_maximum_territorial_value(int ti, int tj, float value)'
          Set a maximum allowed territorial value for the move.

   * `int review_move_reasons(int *i, int *j, float *val, int color)'
          Review the move reasons to find which (if any) move we want
          to play.


File: gnugo.info,  Node: Local MG Functions,  Next: End Game,  Prev: Move Generation Functions,  Up: Move Generation

Local Move Generation Functions
===============================

   The following functions in `move_reasons.c' are declared static.
Their scope is limited to that file.

   * `static int find_worm(int ai, int aj)'
          Find the index of a worm in the list of worms. If necessary,
          add a new entry. (ai, aj) must point to the origin of the
          worm.

   * `static int find_dragon(int ai, int aj)'
          Find the index of a dragon in the list of dragons. If
          necessary, add a new entry. (ai, aj) must point to the origin
          of the dragon.

   * `static int find_connection(int dragon1, int dragon2)'
          Find the index of a connection in the list of connections.
          If necessary, add a new entry.

   * `static int find_semeai(int myworm, int yourworm)'
          Find the index of a semeai in the list of semeais.  If
          necessary, add a new entry.

   * `static int find_worm_pair(int worm1, int worm2)'
          Find the index of an unordered pair of worms in the list of
          worm pairs.  If necessary, add a new entry.

   * `static int find_eye(int i, int j, int color)'
          Find the index of an eye space in the list of eye spaces.  If
          necessary, add a new entry.

   * `static int find_reason(int type, int what)'
          Find a reason in the list of reasons. If necessary, add a new
          entry.

   * `static void add_move_reason(int ti, int tj, int type, int what)'
          Add a move reason for (ti, tj) if it's not already there or
          the table is full.

   * `static void remove_move_reason(int ti, int tj, int type, int
     what)'
          Remove a move reason for (ti, tj). Ignore silently if the
          reason wasn't there.

   * `static int move_reason_known(int ti, int tj, int type, int what)'
          Check whether a move reason already is recorded for a move.

   * `static void find_more_attack_and_defense_moves(int color)'
          Test all moves that defends, attacks, connects or cuts to see
          if they also attack or defend some other worm.

   * `static void remove_opponent_attack_and_defense_moves(int color)'
          Remove attacks on own stones and defense of opponent stones,
          i.e.  moves which are only relevant for the opponent. It
          might seem useful to take these into account (proverb "my
          enemy's vital point is my vital point") but now it seems they
          only lead to trouble.  It's easiest just to remove them
          altogether.

   * `static void do_remove_false_attack_and_defense_moves(void)'
          Remove attacks and defenses that have earlier been marked as
          NON_ATTACK or NON_DEFEND respectively, because they actually
          don't work.

   * `static int strategically_sound_defense(int ai, int aj, int ti,
     int tj)'
          It's often bad to run away with a worm that is in a
          strategically weak position. This function gives heuristics
          for determining whether a move at (ti, tj) to defend the worm
          (ai, aj) is strategically sound. These heuristics need
          improvement. The biggest weakness is that they sometimes fail
          to detect when we're running away towards open ground. It
          would help much to have a reliable escape route mechanism.

   * `static void induce_secondary_move_reasons(int color)'
          Any move that captures or defends a worm also connects or cuts
          the surrounding dragons. Find these secondary move reasons.
             - There is a certain amount of optimizations that could be
               done here.

             - Even when we defend a worm, it's possible that the
               opponent still can secure a connection, e.g. underneath
               a string with few liberties. Thus a defense move isn't
               necessarily a cut move.

             - Connections are transitive. If a move connects A with B
               and B with C, we should infer that it connects A with C
               as well.

   * `static float effective_dragon_size(int ai, int aj)'
          Measure the "effective" size of a dragon. This measure is a
          reasonable approximation of how much area a dragon cover,
          including some amount of surrounding empty spaces.

   * `static float dragon_safety(int ai, int aj, int
     ignore_dead_dragons)'
          An attempt to estimate the safety of a dragon. This should be
          possible to improve considerably. The resulting value is
          interpreted so that 1.0 means a fully safe dragon while 0.0
          is an almost dead dragon.

   * `static float connection_value2(int ai, int aj, int bi, int bj,
     int ti, int tj)'
          Strategical value of connecting (or cutting) the dragon at
          (ai, aj) to the dragon at (bi, bj). This function is
          assymetric.

   * `static void estimate_territorial_value(int m, int n, int color)'
          Estimate the direct territorial value of a move at (m,n).

   * `static void estimate_influence_value(int m, int n, int color)'
          Estimate the influence value of a move at (m,n).

   * `static void estimate_strategical_value(int m, int n, int color)'
          Estimate the strategical value of a move at (m,n).

   * `static int is_antisuji_move(int m, int n)'
          Look through the move reasons to see whether (m, n) is an
          antisuji move.

   * `static float value_move_reasons(int m, int n, int color)'
          Combine the reasons for a move at (m, n) into an old style
          value.  These heuristics are now somewhat less ad hoc but
          probably still need a lot of improvement.

   * `static void value_moves(int color)'
          Loop over all possible moves and value the move reasons for
          each.


File: gnugo.info,  Node: End Game,  Prev: Local MG Functions,  Up: Move Generation

End Game
========

   Endgame moves are generated just like any other move by GNU Go. In
fact, the concept of endgame does not exist explicitly, but if the
largest move initially found is worth 6 points or less, an extra set of
patterns in `endgame.db' is matched and the move valuation is redone.


File: gnugo.info,  Node: Worms and Dragons,  Next: Eyes,  Prev: Move Generation,  Up: Top

Worms and Dragons
*****************

* Menu:

* Worms::                             Worms
* Amalgamation::                      How two Worms are amalgamated.
* Connection::                        Connections.
* Half Eyes::                         Half Eyes and False Eyes.
* Dragons::                           Union of WORMS.
* Dragons in Color::                  Colored display of DRAGONS.
* Worm and Dragon Functions::         Worm and Dragon Functions.
* Dragon2::                           The Second Dragon Array.

   Before considering its move, GNU Go collects some data in several
arrays. Two of these arrays, called `worm' and `dragon', are discussed
in this document. Others are discussed in *Note Eyes::.

   This information is intended to help evaluate the connectedness, eye
shape, escape potential and life status of each group.

   Later routines called by `genmove()' will then have access to this
information. This document attempts to explain the philosophy and
algorithms of this preliminary analysis, which is carried out by the
two routines `make_worm()' and `make_dragon()' in `dragon.c'.

   A "worm" is a maximal set of vertices on the board which are
connected along the horizontal and vertical lines, and are of the same
color, which can be `BLACK', `WHITE' or `EMPTY'. The term `EMPTY'
applied to a worm means that the worm consists of empty (unoccupied)
vertices. It does *not* mean that that the worm is the empty set. A
"string" is a nonempty worm. An empty worm is called a "cavity".  If a
subset of vertices is contained in a worm, there is a unique worm
containing it; this is its "worm closure".

   A "dragon" is a union of strings of the same color which will be
treated as a unit. The dragons are generated anew at each move. If two
strings are in the dragon, it is the computer's working hypothesis that
they will live or die together and are effectively connected.

   The purpose of the dragon code is to allow the computer to formulate
meaningful statements about life and death.  To give one example,
consider the following situation:

           OOOOO
          OOXXXOO
          OX...XO
          OXXXXXO
           OOOOO

   The X's here should be considered a single group with one three-space
eye, but they consist of two separate strings.  Thus we must amalgamate
these two strings into a single dragon. Then the assertion makes sense,
that playing at the center will kill or save the dragon, and is a vital
point for both players. It would be difficult to formulate this
statement if the X's are not perceived as a unit.

   The present implementation of the dragon code involves simplifying
assumptions which can be refined in later implementations.


File: gnugo.info,  Node: Worms,  Next: Amalgamation,  Prev: Worms and Dragons,  Up: Worms and Dragons

Worms
=====

   The array `struct worm_data worm[MAX_BOARD][MAX_BOARD]' collects
information about the worms. We will give definitions of the various
fields. Each field has constant value at each vertex of the worm. We
will define each field.


     struct worm_data {
       int color;
       int size;
       float effective_size;
       int origini;
       int originj;
       int liberties;
       int liberties2;
       int liberties3;
       int liberties4;
       int attacki;
       int attackj;
       int attack_code;
       int defendi;
       int defendj;
       int defend_code;
       int lunchi;
       int lunchj;
       int cutstone;
       int cutstone2;
       int genus;
       int value;
       int ko;
       int inessential;
       int invincible;
       int unconditional_status;
     };

   * `color'
          If the worm is `BLACK' or `WHITE', that is its color.
          Cavities (empty worms) have an additional attribute which we
          call "bordercolor". This will be one of `BLACK_BORDER,'
          `WHITE_BORDER' or `GRAY_BORDER'. Specifically, if all the
          worms adjacent to a given empty worm have the same color
          (black or white) then we define that to be the bordercolor.
          Otherwise the bordercolor is gray.

          Rather than define a new field, we keep this data in the
          field color. Thus for every worm, the color field will have
          one of the following values: `BLACK', `WHITE', `GRAY_BORDER',
          `BLACK_BORDER' or `WHITE_BORDER'.  The last three categories
          are empty worms classified by bordercolor.

   * `size'
          This field contains the cardinality of the worm.

   * `effective_size'
          This is the number of stones in a worm plus the number of
          empty intersections that are at least as close to this worm
          as to any other worm. Intersections that are shared are
          counted with equal fractional values for each worm. This
          measures the direct territorial value of capturing a worm.
          "effective_size" is a floating point number.  Only
          intersections at a distance of 4 or less are counted.

   * `(origini, originj)'
          Each worm has a distinguished member, called its "origin". Its
          coordinates are `(origini, originj)'. The purpose of this
          field is to make it easy to determine when two vertices lie
          in the same worm: we compare their origin. Also if we wish to
          perform some test once for each worm, we simply perform it at
          the origin and ignore the other vertices. The origin is
          characterized by the test:
               (worm[m][n].origini == m) && (worm[m][n].originj == n).

   * `liberties'
          For a nonempty worm the field liberties is the number of
          liberties of the string. This is supplemented by
          `LIBERTIES2', `LIBERTIES3' and `LIBERTIES4', which are the
          number of second order, third order, and fourth order
          liberties, respectively.  The definition of liberties of
          order >1 is adapted to the problem of detecting the shape of
          the surrounding cavity. In particular we want to be able to
          see if a group is loosely surrounded. "a liberty of order n"
          is an empty vertex which may be connected to the string by
          placing n stones of the same color on the board, but no
          fewer. The path of connection may pass through an intervening
          group of the same color. The stones placed at distance >1 may
          not touch a group of the opposite color. Connections through
          ko are not permitted. Thus in the following configuration:
                         .XX...    We label the     .XX.4.
                         XO....    liberties of     XO1234
                         XO....    order < 5 of     XO1234
                         ......    the O group:     .12.4.
                         .X.X..                     .X.X..
          The convention that liberties of order >1 may not touch a
          group of the opposite color means that knight's moves and one
          space jumps are perceived as impenetrable barriers.  This is
          useful in determining when the string is becoming surrounded.

          The path may also not pass through a liberty at distance 1 if
          that liberty is flanked by two stones of the opposing color.
          This reflects the fact that the O stone is blocked from
          expansion to the left by the two X stones in the following
          situation:

                         X.
                         .O
                         X.
          We say that n is the "distance" of the liberty of order n
          from the dragon.

   * `(attacki, attackj)':
          If it is determined that the string may be easily captured,
          `(attacki, attackj)' points to an attacking move. This is
          only used for strings with <5 liberties. If no attacking move
          is found, then `attack_code == 0'.

   * `attack_code'
          1 if the worm can be captured unconditionally, 2 or 3 if it
          can be captured with ko. If it can be captured provided the
          attacker is willing to ignore any ko threat, then the
          `attack_code == 2'. If it can be captured provided the
          attacker can come up with a sufficiently large ko threat,
          then the `attack_code == 3'.

   * `lunch'
          If `lunchi != -1' then `(lunchi, lunchj)' points to a
          boundary worm which can be easily captured.  (It does not
          matter whether or not the string can be defended.)

   * `defend':
          If there is an attack on the string (stored in the `attack'
          field defined above), and there is a move which defends the
          string, this move is stored in `(defendi, defendj)'.
          Otherwise `defend_code == 0'.

   * `defend_code'
          1 if the worm can be defended unconditionally, 2 or 3 if it
          can be defended with ko. If it can be defended provided the
          defender is willing to ignore any ko threat, then the
          `defend_code == 2'. If it can be captured provided the
          defender can come up with a sufficiently large ko threat,
          then the `defend_code == 3'. If there is no attack,
          `defend_code' is 0.

   We have two distinct notions of cutting stone, which we keep track
of in the separate fields `worm.cutstone' and `worm.cutstone2'.  We
maintain both fields because the historically older cutstone field is
needed to deal with the fact that e.g. in the position

        OXX.O
        .OOXO
        OXX.O

the X stones are amalgamated into one dragon because neither cut works
as long as the two O stones are in atari. Therefore we add one to the
cutstone field for each potential cutting point, indicating that these
O stones are indeed worth rescuing.

   For the time being we use both concepts in parallel. It's possible
we also old concept for correct handling of lunches.

   * `cutstone':
          This field is equal to 2 for cutting stones, 1 for potential
          cutting stones. Otherwise it is zero.  Definitions for this
          field: a "cutting stone" is one adjacent to two enemy
          strings, which do not have a liberty in common. The most
          common type of cutting string is in this situation:


                         XO
                         OX

          A "potential cutting stone" is adjacent to two enemy strings
          which do share a liberty. For example, X in:


                         XO
                         O.

          For cutting strings we set `worm[m][n].cutstone=2'. For
          potential cutting strings we set `worm[m][n].cutstone=1'.

   * `cutstone2':
          Cutting points are identified by the patterns in the
          connections database. Proper cuts are handled by the fact
          that attacking and defending moves also count as moves
          cutting or connecting the surrounding dragons.  The cutstone2
          field is set during find_cuts(), called from make_domains().

          The `cutstone2' field is needed to deal with the fact that
          e.g. in the position


                          OXX.O
                          .OOXO
                          OXX.O

          the X stones are amalgamated into one dragon because neither
          cut works as long as the two O stones are in atari. Therefore
          we add one to the cutstone field for each potential cutting
          point, indicating that these O stones are indeed worth
          rescuing.

          For the time being we use both concepts in parallel, with the
          new concept stored in `cutstone2'. It's possible that we have
          to keep the old concept for correct handling of lunches.

   * `genus':
          There are two separate notions of "genus" for worms and
          dragons. The dragon notion is more important, so
          `dragon[m][n].genus' is a far more useful field than
          `worm[m][n].genus'. Both fields are intended as approximations
          to the number of eyes. The "genus" of a string is the number
          of connected components of its complement, minus one. It is
          an approximation to the number of eyes of the string.

   * `ko':
          For every ko, the flag `ko' is set to 1 at the ko stone which
          is in atari, and also at the ko cavity adjacent to it. Thus
          in this situation:


                            XO
                           X.XO
                            XO

          the flag `ko' is set to 1 at the rightmost X stone, and also
          at the cavity to its left.

   * `inessential':
          An "inessential" string is one which meets a criterion
          designed to guarantee that it has no life potential unless a
          particular surrounding string of the opposite color can be
          killed. More precisely an "inessential string" is a string S
          of genus zero, not adjacent to any opponent string which can
          be easily captured, and which has no edge liberties or second
          order liberties, and which satisfies the following further
          property: If the string is removed from the board, then the
          empty worm E which is the worm closure of the set of vertices
          which it occupied has bordercolor the opposite of the removed
          string. The empty worm E (empty, that is, as a worm of the
          board modified by removal of S) consists of the union of
          support of S together with certain other empty worms which we
          call the "boundary components" of S.

          The inessential strings are used in the amalgamation of
          cavities in `make_dragon()'.

   * `invincible':
          An "invincible" worm is one which GNU Go thinks cannot be
          captured. Invincible worms are computed by the function
          `unconditional_life()' which tries to find those worms of the
          given color that can never be captured, even if the opponent
          is allowed an arbitrary number of consecutive moves.

   * unconditional_status
          Unconditional status is also set by the function
          `unconditional_life'. This is set ALIVE for stones which are
          invincible. Stones which can not be turned invincible even if
          the defender is allowed an arbitrary number of consecutive
          moves are given an unconditional status of DEAD. Empty points
          where the opponent cannot form an invincible worm are called
          unconditional territory. The unconditional status is set to
          WHITE_BORDER or BLACK_BORDER depending on who owns the
          territory. Finally, if a stone can be captured but is
          adjacent to unconditional territory of its own color, it is
          also given the unconditional status ALIVE. In all other cases
          the unconditional status is UNKNOWN.

          To make sense of these definitions it is important to notice
          that any stone which is alive in the ordinary sense (even if
          only in seki) can be transformed into an invincible group by
          some number of consecutive moves. Well, this is not entirely
          true because there is a rare class of seki groups not
          satisfying this condition. Exactly which these are is left as
          an exercise for the reader. Currently `unconditional_life',
          which strictly follows the definitions above, calls such seki
          groups unconditionally dead, which of course is a misfeature.
          It is possible to avoid this problem by making the algorithm
          slightly more complex, but this is left for a later revision.


   The function `makeworms()' will generate data for all worms. For
empty worms, the following fields are significant: `color', `size',
`origini' and `originj'. The `liberty', `attack', `defend', `cutstone',
`genus' and `inessential' fields have significance only for nonempty
worms.


File: gnugo.info,  Node: Amalgamation,  Next: Connection,  Prev: Worms,  Up: Worms and Dragons

Amalgamation
============

   A dragon, we have said, is a group of stones which are treated as a
unit. It is a working hypothesis that these stones will live or die
together. Thus the program will not expect to disconnect an opponent's
strings if they have been amalgamated into a single dragon.

   The function `make_dragons()' will amalgamate worms into dragons by
maintaining separate arrays `worm[]' and `dragon[]' containing similar
data. Each dragon is a union of worms. Just as the data maintained in
`worm[][]' is constant on each worm, the data in `dragon[][]' is
constant on each dragon.

   "Amalgamation" of two worms means means in practice replacing the
origin of one worm by the origin of the other.  Amalgamation takes
place in two stages: first, the amalgamation of empty worms (cavities)
into empty dragons (caves); then, the amalgamation of colored worms into
dragons.

Amalgamation of cavities
========================

   As we have already defined it, a cavity is an empty worm. A cave is
an empty dragon.

   Under certain circumstances we want to amalgamate two or more
cavities into a single cave. This is done before we amalgamate strings.
An example where we wish to amalgamate two empty strings is the
following:


           OOOOO
          OOXXXOO
          OXaObXO
          OOXXXOO
           OOOOO

   The two empty worms at a and b are to be amalgamated.

   We have already defined a string to be "inessential" if it meets a
criterion designed to guarantee that it has no life potential unless a
particular surrounding string of the opposite color can be killed. An
"inessential string" is a string S of genus zero which is not a cutting
string or potential cutting string, and which has no edge liberties or
second order liberties (the last condition should be relaxed), and
which satisfies the following further property: If the string is
removed from the board, then the empty worm E which is the worm closure
of the set of vertices which it occupied has bordercolor the opposite
of the removed string.

   Thus in the previous example, after removing the inessential string
at the center the worm closure of the center vertex consists of an empty
worm of size 3 including a and b. The latter are the boundary
components.

   The last condition in the definition of inessential worms excludes
examples such as this:


             OOOO
            OXXOO
           OXX.XO
           OX.XXO
           OOXXO
            OOO

   Neither of the two X strings should be considered inessential
(together they form a live group!) and indeed after removing one of
them the resulting space has gray bordercolor, so by this definition
these worms are not inessential.

   Some strings which should by rights be considered inessential will be
missed by this criterion.

   The algorithm for amalgamation of empty worms consists of
amalgamating the boundary components of any inessential worm. The
resulting dragon has bordercolor the opposite of the removed string.

   Any dragon consisting of a single cavity has bordercolor equal to
that of the cavity.

Amalgamation of strings
=======================

   Amalgamation of nonempty worms in GNU Go 3.0 proceeds as follows.
First we amalgamate all boundary components of an eyeshape. Thus in the
following example:


     .OOOO.       The four X strings are amalgamated into a
     OOXXO.       single dragon because they are the boundary
     OX..XO       components of a blackbordered cave. The
     OX..XO       cave could contain an inessential string
     OOXXO.       with no effect on this amalgamation.
     XXX...

   The code for this type of amalgamation is in the routine
`dragon_eye()', discussed further in EYES.

   Next, we amalgamate strings which seem uncuttable. We amalgamate
dragons which either share two or more common liberties, or share one
liberty into the which the opponent cannot play without being captured.
(ignores ko rule).


        X.    X.X     XXXX.XXX         X.O
        .X    X.X     X......X         X.X
                      XXXXXX.X         OXX

   A database of connection patterns may be found in `patterns/conn.db'.


File: gnugo.info,  Node: Connection,  Next: Half Eyes,  Prev: Amalgamation,  Up: Worms and Dragons

Connection
==========

   The fields `black_eye.cut' and `white_eye.cut' are set where the
opponent can cut, and this is done by the B (break) class patterns in
`conn.db'.  There are two important uses for this field, which can be
accessed by the autohelper functions `xcut()' and `ocut()'. The first
use is to stop amalgamation in positions like


     ..X..
     OO*OO
     X.O.X
     ..O..

where X can play at * to cut off either branch. What happens here is
that first connection pattern CB1 finds the double cut and marks * as a
cutting point. Later the C (connection) class patterns in conn.db are
searched to find secure connections over which to amalgamate dragons.
Normally a diagonal connection would be deemed secure and amalgamated
by connection pattern CC101, but there is a constraint requiring that
neither of the empty intersections is a cutting point.

   A weakness with this scheme is that X can only cut one connection,
not both, so we should be allowed to amalgamate over one of the
connections.  This is performed by connection pattern CC401, which with
the help of `amalgamate_most_valuable_helper()' decides which
connection to prefer.

   The other use is to simplify making alternative connection patterns
to the solid connection. Positions where the diag_miai helper thinks a
connection is necessary are marked as cutting points by connection
pattern 12. Thus we can write a connection pattern like `CC6':


     ?xxx?     straight extension to connect
     XOO*?
     O...?
     
     :8,C,NULL
     
     ?xxx?
     XOOb?
     Oa..?
     
     ;xcut(a) && odefend_against(b,a)

where we verify that a move at `*' would stop the enemy from safely
playing at the cutting point, thus defending against the cut.


File: gnugo.info,  Node: Half Eyes,  Next: Dragons,  Prev: Connection,  Up: Worms and Dragons

Half Eyes and False Eyes
========================

   A "half eye" is a place where, if the defender plays first, an eye
will materialize, but where if the attacker plays first, no eye will
materialize. A "false eye" is a vertex which is surrounded by a dragon
yet is not an eye. Here is a half eye:


     XXXXX
     OO..X
     O.O.X
     OOXXX

   Here is a false eye:


     XXXXX
     XOO.X
     O.O.X
     OOXXX

   The "topological" algorithm for determining half and false eyes is
described elsewhere (*note Eye Topology::).

   The half eye data is collected in the dragon array. Before this is
done, however, an auxiliary array called half_eye_data is filled with
information. The field `type' is 0, or else `HALF_EYE' or `FALSE_EYE'
depending on which type is found; and `(ki, kj)' points to a move to
kill the half eye.


     struct half_eye_data half_eye[MAX_BOARD][MAX_BOARD];
     
     struct half_eye_data {
       int type;         /* HALF_EYE or FALSE_EYE; */
       int num_attacks;  /* number of attacking points */
       int num_defends;  /* number of defending points */
       int ai[4];        /* (ai, aj) attacks a topological halfeye */
       int aj[4];
       int di[4];        /* (di, dj) defends a topological halfeye */
       int dj[4];
     };

   The array `struct half_eye_data half_eye[MAX_BOARD][MAX_BOARD]'
contains information about half and false eyes.  If the type is
`HALF_EYE' then up to four moves are recorded which can either attack
or defend the eye. In rare cases the attack points could be different
from the defense points.

