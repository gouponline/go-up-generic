This is gnugo.info, produced by makeinfo version 4.0 from gnugo.texi.

INFO-DIR-SECTION GNU games
START-INFO-DIR-ENTRY
* GNU go: (gnugo).          The GNU Go program
END-INFO-DIR-ENTRY


File: gnugo.info,  Node: Definitions,  Next: Move Generation Basics,  Up: Overview

Definitions
===========

   A "worm" is a maximal set of vertices on the board which are
connected along the horizontal and vertical lines, and are of the same
color, which can be `BLACK', `WHITE' or `EMPTY'. The term `EMPTY'
applied to a worm means that the worm consists of empty (unoccupied)
vertices. It does *not* mean that that the worm is the empty set. A
"string" is a nonempty worm. An empty worm is called a "cavity".  If a
subset of vertices is contained in a worm, there is a unique worm
containing it; this is its "worm closure". (*note Worms::.)

   A "dragon" is a union of strings of the same color which will be
treated as a unit. If two strings are in the same dragon, it is the
computer's working hypothesis that they will live or die together and
are effectively connected. (*note Dragons::.)

   A "superstring" is a less commonly used unit which is the union of
several strings but generally smaller than a dragon. The superstring
code is in `engine/utils.c'. The definition of a superstring is
slightly different if the code is called from `owl.c' or from
`reading.c'.


File: gnugo.info,  Node: Move Generation Basics,  Next: Examining the Position,  Prev: Definitions,  Up: Overview

Move Generation Basics
======================

   The engine of GNU Go takes a positions and a color to move and
generates the (supposedly) optimal move.  This is done by the function
`genmove()' in `engine/genmove.c'.

   The move generation is done in three passes:

  1. information gathering

  2. different modules propose moves

  3. The values of the moves are weighted together and the best move is
     selected

Information gathering
---------------------

   The information gathering is done by a function `examine_position()',
which will be discussed in greater detail in the next section.  Such
information could be life and death of the groups, information about
moyos, connection of groups and so on. Information gathering is
performed by `examine_position', which in turn calls:

   * `make_worms()'
          Collect information about all connected sets of stones
          (strings) and cavities.  This information is stored in the
          `worm[][]' array. (*note Worms::)

   * `compute_initial_influence()'
          Decides which areas of the board are influenced by which
          player. This function is run a second time later at the end
          of `make_dragons()', since GNU Go's opinion about the safety
          of groups may change, and it is important to have the
          influence function as accurate as possible. *note Influence::

   * `make_dragons()'
          Collect information about connected strings, which are called
          dragons.  Important information here is number of eyes, life
          status, and connectedness between string. (*note Dragons::.)

   A more detailed

Move generation in GNU Go 3.0
-----------------------------

   Once we have found out all about the position it is time to generate
the best move. Moves are proposed by a number of different modules
called "move generators". The move generators themselves do not set the
values of the moves, but enumerate justifications for them, called
"move reasons". The valuation of the moves comes last, after all moves
and their reasons have been generated.

   The move generators in version 3.0 are:

   * `fuseki()'
          Generate a move in the early fuseki.

   * `semeai()'
          Find out if two dead groups of opposite colors are next to
          each other and, if so, try to kill the other group. This
          module will eventually be rewritten along the lines of the
          owl code.

   * `shapes()'
          Find patterns from `patterns/patterns.db' in the current
          position.  Each pattern is matched in each of the 8 possible
          orientations obtainable by rotation and reflection. If the
          pattern matches, a so called "constraint" may be tested which
          makes use of reading to determine if the pattern should be
          used in the current situation.  Such constraints can make
          demands on number of liberties of strings, life and death
          status, and reading out ladders, etc. The patterns may call
          helper functions, which may be hand coded (in
          `patterns/helpers.c') or autogenerated.

          The patterns can be of a number of different classes with
          different goals.  There are e.g. patterns which try to attack
          or defend groups, patterns which try to connect or cut
          groups, and patterns which simply try to make good shape. In
          addition to the large pattern database called by `shapes()',
          pattern matching is used by other modules for different tasks
          throughout the program. *Note Patterns::, for a complete
          documentation of patterns.

   * `atari_atari()'
          See if there are any combination threats and either propose
          them or defend against them.

   * `owl_reasons()'
          The Owl Code (*note The Owl Code::) which has been run during
          `examine_position'), before `owl_reasons()' executes, has
          decided whether different groups can be attacked. The module
          `review_owl_reasons' reviews the statuses of every dragon and
          assigns move reasons for attack and defense. Unlike the other
          move generation modules, this one is called from
          `examine_position()'.

   * `endgame_shapes()'
          If no move is found with a value greater than 6.0, this
          module matches a set of extra patterns which are designed for
          the endgame.  The endgame patterns can be found in
          `patterns/endgame.db'.

   * `revise_semeai()'
          If no move is found, this module changes the status of
          opponent groups involved in a semeai from `DEAD' to
          `UNKNOWN'.  After this, genmove runs `shapes' and
          `endgame_shapes' again to see if a new move turns up.

   * `fill_liberty()'
          Fill a common liberty. This is only used at the end of the
          game. If necessary a backfilling or backcapturing move is
          generated.

Selecting the Move
------------------

   After the move generation modules have run, the best ten moves are
selected by the function `review_move_reasons'. This function also does
some analysis to try to turn up other moves which may have been missed.
The modules `revise_semeai()' and `fill_liberty' are only run if no
good move has been discovered by the other modules.


File: gnugo.info,  Node: Examining the Position,  Next: Sequence of Events,  Prev: Move Generation Basics,  Up: Overview

Examining the Position
======================

   In this section we summarize the sequence of events when
`examine_position()' is run from `genmove()'. This is for reference
only. Don't try to memorize it.

purge persistent reading cache (*note Persistent Cache::)
`make_worms()' (*note Worms::):
  `build_worms()' finds and identifies the worms
  compute effective size of each worm
  `unconditional_life()'
  `find_worm_attacks_and_defenses()':
    for each attackable worm:
      set `worm.attack'
      `add_attack_move()'
    `find_attack_patterns()' to find a few more attacks
    for each defensible worm
      set `worm.defend'
      `add_defense_move'
      if point of attack is not adjacent to worm see if it defends
    `find_defense_patterns()' to find a few more defenses
    for each attackable worm try each liberty
      if it attacks `add_attack_move'
      if it defends `add_defense_move'
  find kos.
  for each worm
    find higher order liberties
  find cutting points (worm.cutstone)
  for each worm compute the genus (*note Worms::)
  `small_semeai()'
  try to improve values of worm.attack and worm.defend
  try to repair situations where adjacent worms can be
    both attacked and defended
  find worm lunches
  find worm threats
`compute_initial_influence()' (*note Influence::)
  `compute_influence()'
    `find_influence_patterns()'
  at each intersection `accumulate_influence()'
  `segment_influence()'
`make_dragons()' (*note Dragons::)
  initialize dragon data
  find the inessential worms
  `make_domains()'
    initialize eye data
    `compute_primary_domains()'
    fill out arrays black_eye and white_eye
      describing eyeshapes
    find_cuts()
    for every eyespace
      `originate_eye()'
    count_neighbors()
  `find_connections()'
  amalgamate dragons sharing an eyespace
  `initialize_supplementary_dragon_data()'
  find adjacent worms which can be captured (dragon lunches)
  find topological half eyes and false eyes
  `modify_eye_spaces()'
  for each eye space
    `compute_eyes()'
    store the results in black_eye, white_eye arrays
  compute the genus of each dragon
  for each dragon
    `compute_escape()'
  `resegment_initial_influence()'
  for each dragon
    `influence_get_moyo_size()'
  for each dragon
     `compute_dragon_status()'
  `find_neighbor_dragons()'
  `purge_persistent_owl_cache()'
  for each dragon which seems surrounded
     try `owl_attack()' and `owl_defend()'
     if appropriate find owl threats
  for each dragon
     set dragon.matcher_status
  for each dragon
     set dragon2.safety
  `semeai()'
  revise opinion of which worms are inessential
  count non-dead dragons of each color
`owl_reasons()' (*note The Owl Code::)
`compute_initial_influence()' again (*note Influence::)


File: gnugo.info,  Node: Sequence of Events,  Next: Roadmap,  Prev: Examining the Position,  Up: Overview

Sequence of Events
==================

   In this section we summarize the sequence of events during the move
generation and selection phases of `genmove()', which take place after
the information gathering phase has been completed.

`fuseki()'
`shapes()'
`review_move_reasons()'
  `find_more_attack_and_defense_moves()'
  `remove_opponent_attack_and_defense_moves()'
  `do_remove_false_attack_and_defense_moves()'
  `examine_move_safety()'
  `induce_secondary_move_reasons()'
  `value_moves()'
  find the ten best moves
if the value of the best move is < 6.0
  `endgame_shapes()'
if no move found yet
  `revise_semeai()'
  `shapes()'
  `endgame_shapes()'
if still no move found
  `fill_liberty()'
if still no move found
    pass


File: gnugo.info,  Node: Roadmap,  Next: Coding Styles,  Prev: Sequence of Events,  Up: Overview

Roadmap
=======

   The GNU Go engine is contained in two directories, `engine/' and
`patterns/'. Code related to the user interface, reading and writing of
smart go format files and testing are found in the directories
`interface/', `sgf/', and `regression/'. Code borrowed from other GNU
programs is contained in `utils/'. Documentation is in `doc/'.

   In this document we will describe some of the individual files
comprising the engine code in `engine/' and `patterns/'. In `interface/'
we mention two files:

   * `gmp.c'
          This is the Go Modem Protocol interface (courtesy of William
          Shubert and others). This takes care of all the details of
          exchanging setup and moves with Cgoban, or any other driving
          program recognizing the Go Modem Protocol.

   * `main.c'
          This contains `main()'. The `gnugo' target is thus built in
          the `interface/' directory.

Files in `engine/'
------------------

   In `engine/' there are the following files:

   * `aftermath.c'
          Contains algorithms which may be called at the end of the
          game to generate moves that will generate moves to settle the
          position, if necessary playing out a position to determine
          exactly the status of every group on the board, which GNU Go
          can get wrong, particularly if there is a seki. This module is
          the basis for the most accurate scoring algorithm available
          in GNU Go.

   * `board.c'
          This file contains code for the maintenance of the board.
          For example it contains the important function `trymove()'
          which tries a move on the board, and `popgo()' which removes
          it by popping the move stack. At the same time vital
          information such as the number of liberties for each string
          and their location is updated incrementally.

   * `clock.c'
          Clock code, including code allowing GNU Go to automatically
          adjust its level in order to avoid losing on time in
          tournaments.

   * `dragon.c'
          This contains `make_dragons()'. This function is executed
          before the move-generating modules `shapes()' `semeai()' and
          the other move generators but after `make_worms'. It tries to
          connect worms into dragons and collect important information
          about them, such as how many liberties each has, whether (in
          GNU Go's opinion) the dragon can be captured, if it lives,
          etc.

   * `fuseki.c'
          Generates fuseki (opening) moves from a database.

   * `filllib.c'
          Code to force filling of dame (backfilling if necessary) at
          the end of the game.

   * `genmove.c'
          This file contains `genmove()' and its supporting routines,
          particularly `examine_position()'.

   * `globals.c'
          This contains the principal global variables used by GNU Go.

   * `gnugo.h'
          This file contains declarations forming the public interface
          to the engine.

   * `hash.c' and `cache.c'
          Hashing code implementing Zobrist hashing. (*note Hashing::)
          The code in `hash.c' provides a way to hash board positions
          into compact descriptions which can be efficiently compared.
          The code in `cache.c' implements a kind of database for
          storing reading results, so they can be quickly retrieved.
          The caching code uses the board hashes as keys to the
          database.  They are split since these functionalities are
          sufficiently demarked that either file could be reimplemented
          without affecting the other one.  Note also that `matchpat()'
          uses the hashing code without also using the caching code.

   * `hash.h' and `cache.h'
          Header files for `hash.c' and `cache.c'.

   * `influence.c' and `influence.h'.
          This code determines which regions of the board are under the
          influence of either player.  (*note Influence::)

   * `liberty.h'
          Header file for the engine. The name "liberty" connotes
          freedom (*note Copying::).

   * `life.c'
          The code in this file contains an alternative approach to
          life and death based on reading instead of the static approach
          in `optics.c'. This code is experimental. It is reasonably
          accurate but too slow. It is activated when gnugo is invoked
          with the `--life' option.

   * `matchpat.c'
          This file contains the pattern matcher `matchpat()', which
          looks for patterns at a particular board location. The actual
          patterns are in the `patterns/' directory. The function
          `matchpat()' is called by every module which does pattern
          matching, notably `shapes'.

   * `move_reasons.c'
          This file contains the code which assigns values to every move
          after all the move reasons are gen

   * `optics.c'
          This file contains the code to recognize eye shapes,
          documented in *Note Eyes::.

   * `owl.c'
          This file does life and death reading. The paradigm is that
          moves are played by both players trying to expand and shrink
          the eyespace until a static configuration is reached where it
          can be analyzed by the code in `optics.c' or `life.c'.

   * `printutils.c'
          Print utilities

   * `reading.c'
          This file contains code to determine whether any given string
          can be attacked or defended. *Note Tactical Reading::, for
          details.

   * `score.c'
          Implements the Bouzy algorithms (*note Moyo::) and contains
          code for scoring the game.

   * `semeai.c'
          This file contains `semeai()', the module which tries to win
          capturing races. This module does not work particularly well
          and will eventually be replaced.

   * `shapes.c'
          This file contains `shapes()', the module called by
          `genmove()' which tries to find moves which match a pattern
          (*note Patterns::).

   * `showbord.c'
          This file contains `showboard()', which draws an ASCII
          representation of the board, depicting dragons (stones with
          same letter) and status (color). This was the primary
          interface in GNU Go 1.2, but is now a debugging aid.

   * `worm.c'
          This file contains `make_worms()', code which is run at the
          beginning of each move cycle, before the code in `dragon.c',
          to determine the attributes of every string. These attributes
          are things like liberties, wether the string can be captured
          (and how), etc

   * `utils.c'
          An assortment of utilities, described in greater detail below.

Files in `patterns/'
--------------------

   The directory `patterns/' contains files related to pattern matching.
Currently there are several types of patterns. A partial list:

   * move generation patterns in `patterns.db' and `patterns2.db'

   * move generation patterns in files `hoshi.db' etc. which are
     automatically build from the files `hoshi.sgf' etc. These comprise
     our small Joseki library.

   * patterns in `owl_attackpats.db', `owl_defendpats.db' and
     `owl_vital_apats.db'. These generate moves for the owl code (*note
     The Owl Code::).

   * Connection patterns in `conn.db' (*note Connections Database::)

   * Influence patterns in `influence.db' and `barriers.db' (*note
     Influence::)

   * eye patterns in `eyes.db' (*note Eyes::).

   The following list contains, in addition to distributed source files
some intermediate automatically generated files such as patterns.c.
These are C source files produced by "compiling" various pattern
databases, or in some cases (such as `hoshi.db') themselves
automatically generated pattern databases produced by "compiling"
joseki files in Smart Go Format.

   * `conn.db':
          Database of connection patterns.

   * `conn.c':
          Automatically generated file, containing connection patterns
          in form of struct arrays, compiled by `mkpat' from `conn.db'.

   * `eyes.c':
          Automatically generated file, containing eyeshape patterns in
          form of struct arrays, compiled by `mkpat' from `eyes.db'.

   * `eyes.h':
          Header file for `eyes.c'.

   * `eyes.db':
          Database of eyeshape patterns. *Note Eyes::, for details.

   * `helpers.c':
          These are helper functions to assist in evaluating moves by
          matchpat.

   * `hoshi.sgf':
          Smart Go Format file containing 4-4 point openings

   * `hoshi.db':
          Automatically generated database of 4-4 point opening
          patterns, make by compiling `hoshi.sgf'

   * `joseki.c':
          Joseki compiler, which takes a joseki file in Smart Go
          Format, and produces a pattern database.

   * `komoku.sgf':
          Smart Go Format file containing 3-4 point openings

   * `komoku.db':
          Automatically generated database of 3-4 point opening
          patterns, make by compiling `komoku.sgf'

   * `mkeyes.c':
          Pattern compiler for the eyeshape databases. This program
          takes `eyes.db' as input and produces `eyes.c' as output.

   * `mkpat.c':
          Pattern compiler for the move generation and connection
          databases. Takes the file `patterns.db' together with the
          autogenerated Joseki pattern files `hoshi.db', `komoku.db',
          `sansan.db', `mokuhadzushi.db', `takamoku.db' and produces
          `patterns.c', or takes `conn.db' and produces `conn.c'.

   * `mokuhazushi.sgf':
          Smart Go Format file containing 5-3 point openings

   * `mokuhazushi.db':
          Pattern database compiled from mokuhadzushi.sgf

   * `sansan.sgf':
          Smart Go Format file containing 3-3 point openings

   * `sansan.db':
          Pattern database compiled from `sansan.sgf'

   * `takamoku.sgf':
          Smart Go Format file containing 5-4 point openings

   * `takamoku.db':
          Pattern database compiled from takamoku.sgf.

   * `patterns.c':
          Pattern data, compiled from patterns.db by mkpat.

   * `patterns.h':
          Header file relating to the pattern databases.

   * `patterns.db' and `patterns2.db':
          These contain pattern databases in human readable form.



File: gnugo.info,  Node: Coding Styles,  Next: Navigating the Source,  Prev: Roadmap,  Up: Overview

Coding styles and conventions
=============================

Coding Conventions
------------------

   Please follow the coding conventions at:
<http://www.gnu.org/prep/standards_toc.html>

   Please preface every function with a brief description of its usage.

   Please help to keep this Texinfo documentation up-to-date.

Tracing
-------

   A function `gprintf()' is provided. It is a cut-down `printf',
supporting only `%c', `%d', `%s', and without field widths, etc. It
does, however, add some useful facilities:

   * `%m':
          Takes two parameters, and displays a formatted board
          co-ordinate.

   * indentation:
          Trace messages are automatically indented to reflect the
          current stack depth, so it is clear during read-ahead when it
          puts a move down or takes one back.

   * "outdent":
          format string suppresses the indentation.

   A variant `mprintf' sends output to stderr. Normally `gprintf()' is
wrapped in one of the following:

   `TRACE(fmt, ...)':
     Print the message if the 'verbose' variable > 0.  (verbose is set
     by `-t' on the command line)

   `DEBUG(flags, fmt, ...)':
     While `TRACE' is intended to afford an overview of what GNU Go is
     considering, `DEBUG' allows occasional in depth study of a module,
     usually needed when something goes wrong. `flags' is one of the
     `DEBUG_*' symbols in `engine/gnugo.h'.  The `DEBUG' macro tests to
     see if that bit is set in the `debug' variable, and prints the
     message if it is.  The debug variable is set using the `-d'
     command-line option.

   The variable `verbose' controls the tracing. It can equal 0 (no
trace), 1, 2, 3 or 4 for increasing levels of tracing. You can set the
trace level at the command line by `-t' for `verbose=1', `-t -t' for
`verbose=2', etc. But in practice if you want more verbose tracing than
level 1 it is better to use gdb to reach the point where you want the
tracing; you will often find that the variable `verbose' has been
temporarily set to zero and you can use the gdb command `set var
verbose=1' to turn the tracing back on.

Assertions
----------

   Related to tracing are assertions. Developers are strongly encouraged
to pepper their code with assertions to ensure that data structures are
as they expect. For example, the helper functions make assertions about
the contents of the board in the vicinity of the move they are
evaluating.

   `ASSERT()' is a wrapper around the standard C `assert()' function.
In addition to the test, it takes an extra pair of parameters which are
the co-ordinates of a "relevant" board position. If an assertion fails,
the board position is included in the trace output, and `showboard()'
and `popgo()' are called to unwind and display the stack.

FIXME
-----

   We have adopted the convention of putting the word FIXME in comments
to denote known bugs, etc.


File: gnugo.info,  Node: Navigating the Source,  Prev: Coding Styles,  Up: Overview

Navigating the Source
=====================

   If you are using Emacs, you may find it fast and convenient to use
Emacs' built-in facility for navigating the source. Switch to the root
directory `gnugo-3.0.x/' and execute the command:

     find . -print|grep "\.[ch]$"|xargs etags

   This will build a file called `gnugo-3.0.x/TAGS'. Now to find any
GNU Go function, type `M-.' and enter the command which you wish to
find, or just `RET' if the cursor is at the name of the function sought.

   The first time you do this you will be prompted for the location of
the TAGS table.  Enter the path to `gnugo-3.0.x/TAGS', and henceforth
you will be able to find any function with a minimum of keystrokes.


File: gnugo.info,  Node: Analyzing,  Next: API,  Prev: Overview,  Up: Top

Analyzing GNU Go's moves
************************

   In this chapter we will discuss methods of finding out how GNU Go
understands a given position. These methods will be of interest to
anyone working on the program, or simply curious about its workings.

   We assume that you have a game GNU Go played saved as an sgf file,
and you want to know why it made a certain move.

* Menu:

* Traces::			Analyzing traces in GNU Go 3.0
* Output File::			The Output File
* Decide string::		Checking the reading code
* Decide dragon::		Checking the owl code
* GTP and GDB techniques::      GTP and GDB techniques
* Debugboard::                  Debugboard
* Scoring::                     Finding out the winner of the game
* Colored Display::             Colored Display


File: gnugo.info,  Node: Traces,  Next: Output File,  Prev: Analyzing,  Up: Analyzing

Interpreting Traces
===================

   A quick way to find out roughly the reason for a move is to run

     gnugo -l FILENAME -t -L MOVE NUMBER

   (You may also want to add `--quiet' to suppress the copyright
message.) In GNU Go 3.0, the moves together with their reasons are
listed, followed by a numerical analysis of the values given to each
move.

   If you are tuning (*note Tuning::) you may want to add the `-a'
option. This causes GNU Go to report all patterns matched, even ones
that cannot affect the outcome of the move. The reasons for doing this
is that you may want to modify a pattern already matched instead of
introducing a new one.

   If you use the `-w' option, GNU Go will report the statuses of
dragons around the board. This type of information is available by
different methods, however (*note Debugboard::, *note Colored
Display::).


File: gnugo.info,  Node: Output File,  Next: Decide string,  Prev: Traces,  Up: Analyzing

The Output File
===============

   If GNU Go is invoked with the option `-o filename' it will produce
an output file. This option can be added at the command line in the Go
Modem Protocol Setup Window of CGoban. The output file will show the
locations of the moves considered and their weights. It is worth noting
that by enlarging the CGoban window to its fullest size it can display
3 digit numbers. Dragons with status `DEAD' are labelled with an `X',
and dragons with status `CRITICAL' are labelled with a `!'.

   If you have a game file which is not commented this way, or which
was produced by a non-current version of GNU Go you may ask GNU Go to
produce a commented version by running:

     gnugo --quiet -l <old file> --replay <color> -o <new file>

Here <color> can be 'black,' 'white' or 'both'. The replay option will
also help you to find out if your current version of GNU Go would play
differently than the program that created the file.


File: gnugo.info,  Node: Decide string,  Next: Decide dragon,  Prev: Output File,  Up: Analyzing

Checking the reading code
=========================

   The `--decide-string' option is used to check the tactical reading
code (*note Tactical Reading::). This option takes an argument, which
is a location on the board in the usual algebraic notation (e.g.
`--decide-string C17'). This will tell you whether the reading code (in
`engine/reading.c') believes the string can be captured, and if so,
whether it believes it can be defended, which moves it finds to attack
or defend the move, how many nodes it searched in coming to these
conclusions. Note that when GNU Go runs normally (not with
`--decide-string') the points of attack and defense are computed when
`make_worms()' runs and cached in `worm.attack' and `worm.defend'.

   If used with an output file (`-o FILENAME') `--decide-string' will
produce a variation tree showing all the variations which are
considered. This is a useful way of debugging the reading code, and
also of educating yourself with the way it works. The variation tree
can be displayed graphically using CGoban.

   At each node, the comment contains some information. For example you
may find a comment:


     attack4-B at D12 (variation 6, hash 51180fdf)
     break_chain D12: 0
     defend3 D12: 1 G12 (trivial extension)

   This is to be interpreted as follows. The node in question was
generated by the function `attack3()' in `engine/reading.c', which was
called on the string at `D12'. Of the data in parentheses tells you the
values of `count_variations' and `hashdata.hashval'.

   The second value ("hash") you probably will not need to know unless
you are debugging the hash code, and we will not discuss it.  But the
first value ("variation") is useful when using the debugger `gdb'. You
can first make an output file using the `-o' option, then walk through
the reading with `gdb', and to coordinate the SGF file with the
debugger, display the value of `count_variations'. Specifically, from
the debugger you can find out where you are as follows:

     (gdb) set dump_stack()
     B:D13 W:E12 B:E13 W:F12 B:F11  (variation 6)

   If you place yourself right after the call to `trymove()' which
generated the move in question, then the variation number in the SGF
file should match the variation number displayed by `dump_stack()', and
the move in question will be the last move played (F11 in this example).

   This displays the sequence of moves leading up to the variation in
question, and it also prints `count_variations-1'.

   The second two lines tell you that from this node, the function
`break_chain()' was called at D12 and returned 0 meaning that no way
was found of rescuing the string by attacking an element of the
surrounding chain, and the function `defend3()' was called also at D12
and returned 1, meaning that the string can be defended, and that G12
is the move that defends it. If you have trouble finding the function
calls which generate these comments, try setting `sgf_dumptree=1' and
setting a breakpoint in `sgf_trace'.


File: gnugo.info,  Node: Decide dragon,  Next: GTP and GDB techniques,  Prev: Decide string,  Up: Analyzing

Checking the Owl code
=====================

   You can similarly debug the Owl code using the option
`--decide-dragon'. Usage is entirely similar to `--decide-string', and
it can be used similarly to produce variation trees. These should be
typically much smaller than the variation trees produced by
`--decide-string'.


File: gnugo.info,  Node: GTP and GDB techniques,  Next: Debugboard,  Prev: Decide dragon,  Up: Analyzing

GTP and GDB techniques
======================

   You can use the Go Text Protocol (*note GTP::) to determine the
statuses of dragons and other information needed for debugging. The GTP
command `dragon_data P12' will list the dragon data of the dragon at
`P12' and `worm_data' will list the worm data; other GTP commands may
be useful as well.

   You can also conveniently get such information from GDB.  A
suggested `.gdbinit' file may be found in *Note Debugging::. Assuming
this file is loaded, you can list the dragon data with the command:

     (gdb) dragon P12

   Similarly you can get the worm data with `worm P12'.


File: gnugo.info,  Node: Debugboard,  Next: Scoring,  Prev: GTP and GDB techniques,  Up: Analyzing

Debugboard
==========

   A useful utility called `debugboard' is made in the
`interface/debugboard/' directory. This can be run in an Xterm. Use a
smaller font since it requires 50 rows and 80 columns. This runs
`examine_position()', then makes a graphical display of the board.
Using the cursor movement keys, you can move around the board and find
out the contents of the worm, dragon and eye arrays.


File: gnugo.info,  Node: Scoring,  Next: Colored Display,  Prev: Debugboard,  Up: Analyzing

Scoring the game
================

   GNU Go can score the game. If done at the last move, this is usually
accurate unless there is a seki. Normally GNU Go will report its
opinion about the score at the end of the game, but if you want this
information about a game stored in a file, use the `--score' option.

     gnugo --score last -l filename

loads the sgf file to the end of the file and estimates the winner
after the last stored move by estimating the territory.

     gnugo --score end -l filename

loads the sgf file and GNU Go continues to play after the last stored
move by itself up to the very end.  Then the winner is determined by
estimating the territory.

     gnugo --score aftermath -l filename

loads the sgf file and GNU Go continues to play after the last stored
move by itself up to the very end. Then the winner is determined by the
most accurate algorithm available. Slower but more accurate than
`--score end'.

     gnugo --score L10 -l filename

loads the sgf file until a stone is placed on L10. Now the winner will
be estimated as with `gnugo --score last'.

   Any of these commands may be combined with `--chinese-rules' if you
want to use Chinese (area) counting.

     gnugo --score 100 -l filename

loads the sgf file until move number 100. Now the winner will be
estimated as with `gnugo --score last'.

   If the option `-o OUTPUTFILENAME' is provided, the results will also
be written as comment at the end of the output file.


File: gnugo.info,  Node: Colored Display,  Prev: Scoring,  Up: Analyzing

Colored Display
===============

   Various colored displays of the board may be obtained in a color
`xterm' or `rxvt' window. Xterm will only work if xterm is not compiled
with color support. If the colors are not displayed on your xterm, try
`rxvt'.  You may also use the Linux console. The colored display will
work best if the background color is black; if this is not the case you
may want to edit your `.Xdefaults' file or add the options `-bg black
-fg white' to `xterm' or `rxvt'.

Dragon Display
--------------

   You can get a colored ASCII display of the board in which each dragon
is assigned a different letter; and the different `matcher_status'
values (`ALIVE', `DEAD', `UNKNOWN', `CRITICAL') have different colors.
This is very handy for debugging. Actually two diagrams are generated.
The reason for this is concerns the way the matcher status is computed.
The dragon_status (*note Dragons::) is computed first, then for some,
but not all dragons, a more accurate owl status is computed. The
matcher status is the owl status if available; otherwise it is the
dragon_status. Both the dragon_status and the owl_status are displayed.
The color scheme is as follows:

     green = alive
     cyan = dead
     red = critical
     yellow = unknown
     magenta = unchecked

   To get the colored display, save a game in sgf format using CGoban,
or using the `-o' option with GNU Go itself.

   Open an `xterm' or `rxvt' window.

   Execute `gnugo -l [filename] -L [movenum] -T' to get the colored
display.

   Other useful colored displays may be obtained by using instead:

Eye Space Display
-----------------

   Instead of `-T', try this with `-E'. This gives a colored display of
the eyespaces, with marginal eye spaces marked `!' (*note Eyes::).

Moyo Display
------------

   The option `-m LEVEL' can give colored displays of the various
quantities which are computed in `engine/moyo.c'.

   The moyos found by GNU Go can be displayed from an xterm or rxvt
window or from the Linux console using the `-m' option. This takes a
parameter:


     `-m LEVEL'
      use or (hexadecimal)   cumulative values for printing these reports :
         1       0x01         ascii printing of territorial evaluation (5/21)
         2       0x02         ascii printing of moyo evaluation (5/10)
         4       0x04         ascii printing of area (4/0)
         8       0x08         print initial moyo influence
        16       0x10         print influence
        32       0x20         numeric influence
        64       0x40         moyo strength
       128       0x80         moyo attenuation

   The first three options are somewhat superceded because these data
are no longer used by the engine.

These options can be combined by adding the levels. Levels 16, 32, 64
and 128 don't do much unless you also specify level 8.  Thus one might
use the hexadecimal option `-m0x018' if you want to see the influence
function displayed graphically.

   *Note Moyo::, for the first three items.

   *Note Influential Display::, for the last five items.


File: gnugo.info,  Node: API,  Next: SGF,  Prev: Analyzing,  Up: Top

Application Programmers Interface to GNU Go
*******************************************

   If you want to write your own interface to GNU Go, or if you want to
create a go application using the GNU Go engine, this chapter is of
interest to you.

   First an overview: GNU Go consists of two parts: the GNU Go engine
and a program (user interface) which uses this engine. These are linked
together into one binary. The current program implements the following
user modes:

   * An interactive board playable on ASCII terminals

   * solo play - GNU Go plays against itself

   * replay - a mode which lets the user investigate moves in an
     existing SGF file.

   * GMP - Go Modem Protocol, a protocol for automatic play between two
     computers.

   * GTP - Go Text Protocol, a more general go protocol currently used
     only for testing of the engine. However, GTP is currently being
     standardized and it is expected that GTP will become the main
     choice for tasks where currently GMP is used.

   The GNU Go engine can be used in other applications. For example,
supplied with GNU Go is another program using the engine, called
`debugboard', in the directory `interface/debugboard/'. The program
debugboard lets the user load SGF files and can then interactively look
at different properties of the position such as group status and eye
status.

   The purpose of this Chapter is to show how to interface your own
program such as `debugboard' with the GNU Go engine.

   Figure 1 describes the structure of a program using the GNU Go
engine.

                      +-----------------------------------+
                      |                                   |
                      |          Go application           |
                      |                                   |
                      +-----+----------+------+           |
                      |     |          |      |           |
                      |     |   Game   |      |           |
                      |     | handling |      |           |
                      |     |          |      |           |
                      |     +----+-----+      |           |
                      |   SGF    |    Move    |           |
                      | handling | generation |           |
                      |          |            |           |
                      +----------+------------+-----------+
                      |                                   |
                      |           Board handling          |
                      |                                   |
                      +-----------------------------------+
     
             Figure 1: The structure of a program using the GNU Go engine

   The foundation is a library called `libboard.a' which provides
efficient handling of a go board with rule checks for moves, with
incremental handling of connected strings of stones and with methods to
efficiently hash go positions.

   On top of this, there is a library which helps the application use
smart go files, SGF files, with complete handling of game trees in
memory and in files. This library is called `libsgf.a'

   The main part of the code within GNU Go is the move generation
library which given a position generates a move. This part of the
engine can also be used to manipulate a go position, add or remove
stones, do tactical and strategic reading and to query the engine for
legal moves. These functions are collected into `libengine.a'.

   The game handling code helps the application programmer keep tracks
of the moves in a game, and to undo or redo moves. Games can be saved to
SGF files and then later be read back again. These are also within
`libengine.a'.

   The resposibility of the application is to provide the user with a
user interface, graphical or not, and let the user interact with the
engine.

* Menu:

* Getting Started::          How to use the engine in your program
* Basic Data Structures::    Basic Data Structures in the Engine
* The Position Struct::      The Position `struct'
* Positional Functions::     Functions which manipulate a Position


File: gnugo.info,  Node: Getting Started,  Next: Basic Data Structures,  Prev: API,  Up: API

How to use the engine in your own program: getting started
==========================================================

   To use the GNU Go engine in your own program you must include the
file `gnugo.h'. This file describes the whole public API. There is
another file, `liberty.h', which describes the internal interface within
the engine. If you want to make a new module within the engine, e.g.
for suggesting moves you will have to include this file also. In this
section we will only describe the public interface.

   Before you do anything else, you have to call the function
`init_gnugo()'. This function initializes everything within the engine.
It takes one parameter: the number of megabytes the engine can use for
the internal hash table. In addition to this the engine will use a few
megabytes for other purposes such as data describing groups (liberties,
life status, etc), eyes and so on.


File: gnugo.info,  Node: Basic Data Structures,  Next: The Position Struct,  Prev: Getting Started,  Up: API

Basic Data Structures in the Engine
===================================

   There are some basic definitions in gnugo.h which are used
everywhere. The most important of these are the numeric declarations of
colors. Each intersection on the board is represented by one of these:


          color              value
          EMPTY                0
          WHITE                1
          BLACK                2

   In addition to these, the following values can be used in special
places, such as describing the borders of eyes:


          color                     value
          GRAY (GRAY_BORDER)          3
          WHITE_BORDER                4
          BLACK_BORDER                5

   There is a macro, `OTHER_COLOR(color)' which can be used to get the
other color than the parameter. This macro can only be used on `WHITE'
or `BLACK', but not on `EMPTY' or one of the border colors.


File: gnugo.info,  Node: The Position Struct,  Next: Positional Functions,  Prev: Basic Data Structures,  Up: API

The Position Struct
===================

   The basic data structure in the interface to the engine is the
`Position'. A `Position' is used to store the current position of a
game including the location of all black and white stones, a possible
ko, and the number of captured stones on each side.  Here is the
definition of `Position':


          typedef unsigned char Intersection;
     
          typedef struct {
            int          boardsize;
            Intersection board[MAX_BOARD][MAX_BOARD];
            int          ko_i;
            int          ko_j;
            int          last_i[2];
            int          last_j[2];
     
            float        komi;
            int          white_captured;
            int          black_captured;
          } Position;

   Here `Intersection' stores `EMPTY', `WHITE' or `BLACK'. It is
currently defined as an `unsigned char' to make it reasonably efficient
in both storage and access time. The position stores a two-dimensional
array of Intersections with the size `MAX_BOARD'. `MAX_BOARD' is the
value of the biggest board size that the engine supports; it is
currently set to 21. There is also a `MIN_BOARD' which is set to 3.

   To indicate what board size is actually used, there is a member,
`boardsize', which should be in the range between `MIN_BOARD' and
`MAX_BOARD'.

   A location on the board is represented by a pair of integers in the
range `[0 ... boardsize-1]'. The convention used within GNU Go is that
the first integer indicates the row number from the top and the second
integer indicates the column number from the left. Thus the coordinate
(2,5) is F5 (A) in the small diagram below.


                A B C D E F G
              7 . . . . . . . 7
              6 . . . . . . . 6
              5 . . . . . A . 5
              4 . . . . . . . 4
              3 . . . . . . . 3
              2 . . . . . . . 2
              1 . . . . . . . 1
                A B C D E F G

   A pass move is represented by the pair `(-1,-1)'.  A convention
within the code is to use the suffix `i' and `j' for the first and the
last coordinate.

   If there is a ko present on the board, that is if one stone was
captured the last move and the capturing stone can be recaptured, the
pair `(ko_i, ko_j)' points at the empty intersection where the stone was
just captured (`a' in the diagram below).


                A B C D E F G
              7 . . . . . . . 7
              6 . . . . . . . 6
              5 . . . O X . . 5
              4 . . O a O X . 4
              3 . . . O X . . 3
              2 . . . . . . . 2
              1 . . . . . . . 1
                A B C D E F G

   If no ko is present, `ko_i' should be set to `-1'.

   The last two moves played are stored in `(last_i[], last_j[])'.

   As the game progresses the number of prisoners on each side are
maintained in the members `white_captured' and `black_captured'.

   The komi used in the ongoing game is also stored in the `Position'.
The reason for this is that in some instances, GNU Go plays differently
whether it is ahead, behind or the position is even.  So the komi is an
important input to the move generation.

