This is gnugo.info, produced by makeinfo version 4.2 from gnugo.texi.

INFO-DIR-SECTION GNU games
START-INFO-DIR-ENTRY
* GNU Go: (gnugo).          The GNU Go program
END-INFO-DIR-ENTRY


File: gnugo.info,  Node: API,  Next: GTP,  Prev: Utility Functions,  Up: Top

Application Programmers Interface to GNU Go
*******************************************

   If you want to write your own interface to GNU Go, or if you want to
create a go application using the GNU Go engine, this chapter is of
interest to you.

   First an overview: GNU Go consists of two parts: the GNU Go engine
and a program (user interface) which uses this engine. These are linked
together into one binary. The current program implements the following
user modes:

   * An interactive board playable on ASCII terminals

   * solo play - GNU Go plays against itself

   * replay - a mode which lets the user investigate moves in an
     existing SGF file.

   * GMP - Go Modem Protocol, a protocol for automatic play between two
     computers.

   * GTP - Go Text Protocol, a more general go protocol, *note GTP::.

   The GNU Go engine can be used in other applications. For example,
supplied with GNU Go is another program using the engine, called
`debugboard', in the directory `interface/debugboard/'. The program
debugboard lets the user load SGF files and can then interactively look
at different properties of the position such as group status and eye
status.

   The purpose of this Chapter is to show how to interface your own
program such as `debugboard' with the GNU Go engine.

   Figure 1 describes the structure of a program using the GNU Go
engine.

                      +-----------------------------------+
                      |                                   |
                      |          Go application           |
                      |                                   |
                      +-----+----------+------+           |
                      |     |          |      |           |
                      |     |   Game   |      |           |
                      |     | handling |      |           |
                      |     |          |      |           |
                      |     +----+-----+      |           |
                      |   SGF    |    Move    |           |
                      | handling | generation |           |
                      |          |            |           |
                      +----------+------------+-----------+
                      |                                   |
                      |           Board handling          |
                      |                                   |
                      +-----------------------------------+
     
             Figure 1: The structure of a program using the GNU Go engine

   The foundation is a library called `libboard.a' which provides
efficient handling of a go board with rule checks for moves, with
incremental handling of connected strings of stones and with methods to
efficiently hash go positions.

   On top of this, there is a library which helps the application use
Smart Game Format (SGF) files, with complete handling of game trees in
memory and in files. This library is called `libsgf.a'

   The main part of the code within GNU Go is the move generation
library which given a position generates a move. This part of the
engine can also be used to manipulate a go position, add or remove
stones, do tactical and strategic reading and to query the engine for
legal moves. These functions are collected into `libengine.a'.

   The game handling code helps the application programmer keep tracks
of the moves in a game. Games can be saved to SGF files and then later
be read back again. These are also within `libengine.a'.

   The responsibility of the application is to provide the user with a
user interface, graphical or not, and let the user interact with the
engine.

* Menu:

* Getting Started::          How to use the engine in your program
* Basic Data Structures::    Basic Data Structures in the Engine
* The Board State::          The board_state `struct'
* Positional Functions::     Functions which manipulate a Position


File: gnugo.info,  Node: Getting Started,  Next: Basic Data Structures,  Up: API

How to use the engine in your own program: getting started
==========================================================

   To use the GNU Go engine in your own program you must include the
file `gnugo.h'. This file describes the whole public API. There is
another file, `liberty.h', which describes the internal interface within
the engine. If you want to make a new module within the engine, e.g.
for suggesting moves you will have to include this file also. In this
section we will only describe the public interface.

   Before you do anything else, you have to call the function
`init_gnugo()'. This function initializes everything within the engine.
It takes one parameter: the number of megabytes the engine can use for
the internal hash table. In addition to this the engine will use a few
megabytes for other purposes such as data describing groups (liberties,
life status, etc), eyes and so on.


File: gnugo.info,  Node: Basic Data Structures,  Next: The Board State,  Prev: Getting Started,  Up: API

Basic Data Structures in the Engine
===================================

   There are some basic definitions in gnugo.h which are used
everywhere. The most important of these are the numeric declarations of
colors. Each intersection on the board is represented by one of these:


          color              value
          EMPTY                0
          WHITE                1
          BLACK                2

   There is a macro, `OTHER_COLOR(color)' which can be used to get the
other color than the parameter. This macro can only be used on `WHITE'
or `BLACK', but not on `EMPTY'.

   GNU Go uses two different representations of the board, for most
purposes a one-dimensional one, but for a few purposes a two
dimensional one (*note Libboard::). The one-dimensional board was
introduced before GNU Go 3.2, while the two-dimensional board dates
back to the ancestral program written by Man Lung Li before 1995. The
API still uses the two-dimensional board, so the API functions have not
changed much since GNU Go 3.0.


File: gnugo.info,  Node: The Board State,  Next: Positional Functions,  Prev: Basic Data Structures,  Up: API

The board_state struct
======================

   A basic data structure in the engine is the `board_state' struct.
This structure is internal to the engine and is defined in `liberty.h'.


          typedef unsigned char Intersection;
     
          struct board_state {
            int board_size;
     
            Intersection board[BOARDSIZE];
            int board_ko_pos;
            int black_captured;
            int white_captured;
     
            Intersection initial_board[BOARDSIZE];
            int initial_board_ko_pos;
            int initial_white_captured;
            int initial_black_captured;
            int move_history_color[MAX_MOVE_HISTORY];
            int move_history_pos[MAX_MOVE_HISTORY];
            int move_history_pointer;
     
            float komi;
            int move_number;
          };

   Here `Intersection' stores `EMPTY', `WHITE' or `BLACK'. It is
currently defined as an `unsigned char' to make it reasonably efficient
in both storage and access time. The board state contains an array of
`Intersection''s representing the board.  The move history is contained
in the struct. Also contained in the struct is the location of a ko
(`EMPTY') if the last move was not a ko capture, the komi, the number
of captures, and corresponding data for the initial position at the
beginning of the move history.


File: gnugo.info,  Node: Positional Functions,  Prev: The Board State,  Up: API

Functions which manipulate a Position
=====================================

   All the functions in the engine that manipulate Positions have names
prefixed by `gnugo_'. These functions still use the two-dimensional
representation of the board (*note The Board Array::). Here is a
complete list, as prototyped in `gnugo.h':

   * `void init_gnugo(float memory)'

          Initialize the gnugo engine. This needs to be called once
          only.

   * `void gnugo_clear_board(int boardsize)'

          Clear the board.

   * `void gnugo_set_komi(float new_komi)'

          Set the komi.

   * `void gnugo_add_stone(int i, int j, int color)'

          Place a stone on the board

   * `void gnugo_remove_stone(int i, int j)'

          Remove a stone from the board

   * `int gnugo_is_pass(int i, int j)'

          Return true if (i,j) is PASS_MOVE

   * `void gnugo_play_move(int i, int j, int color)'

          Play a move and start the clock

   * `int gnugo_undo_move(int n)'

          Undo n permanent moves. Returns 1 if successful and 0 if it
          fails.  If n moves cannot be undone, no move is undone.

   * `int gnugo_play_sgfnode(SGFNode *node, int to_move)'

          Perform the moves and place the stones from the SGF node on
          the board. Return the color of the player whose turn it is to
          move.

   * `int gnugo_play_sgftree(SGFNode *root, int *until, SGFNode
     **curnode)'

          Play the moves in ROOT UNTIL movenumber is reached.  Return
          the color of the player whose turn it is to move.

   * `int gnugo_is_legal(int i, int j, int color)'

          Interface to `is_legal()'.

   * `int gnugo_is_suicide(int i, int j, int color)'

          Interface to `is_suicide()'.

   * `int gnugo_placehand(int handicap)'

          Interface to placehand. Sets up handicap pieces and returns
          the number of placed handicap stones.

   * `void gnugo_recordboard(SGFNode *root)'

          Interface to `sgffile_recordboard()'

   * `int gnugo_sethand(int handicap, SGFNode *node)'

          Interface to placehand. Sets up handicap stones and returns
          the number of placed handicap stones, updating the sgf file

   * `int gnugo_genmove(int *i, int *j, int color)'

          Interface to `genmove()'.

   * `int gnugo_attack(int m, int n, int *i, int *j)'

          Interface to `attack()'.

   * `int gnugo_find_defense(int m, int n, int *i, int *j)'

          Interface to `find_defense()'.

   * `void gnugo_who_wins(int color, FILE *outfile)'

          Interface to `who_wins()'.

   * `float gnugo_estimate_score(float *upper, float *lower)'

          Put upper and lower score estimates into `*upper', `*lower'
          and return the average. A positive score favors white. In
          computing the upper bound, `CRITICAL' dragons are awarded to
          white; in computing the lower bound, they are awarded to
          black.

   * `void gnugo_examine_position(int color, int how_much)'

          Interface to `examine_position'.

   * `int gnugo_get_komi()'

          Report the komi.

   * `void gnugo_get_board(int b[MAX_BOARD][MAX_BOARD])'

          Place the board into the `b' array.

   * `int gnugo_get_boardsize()'

          Report the board size.

   * `int gnugo_get_move_number()'

          Report the move number.

Game handling
=============

   The functions (in *note Positional Functions::) are all that are
needed to create a fully functional go program.  But to make the life
easier for the programmer, there is a small set of functions specially
designed for handling ongoing games.

   The data structure describing an ongoing game is the `Gameinfo'. It
is defined as follows:


     typedef struct {
       int       handicap;
     
       int       to_move;            /* whose move it currently is */
       SGFTree   game_record;        /* Game record in sgf format. */
     
       int       computer_player;    /* BLACK, WHITE, or EMPTY (used as BOTH) */
     
       char      outfilename[128];   /* Trickle file */
       FILE      *outfile;
     } Gameinfo;

   The meaning of `handicap' should be obvious. `to_move' is the color
of the side whose turn it is to move.

   The SGF tree `game_record' is used to store all the moves in the
entire game, including a header node which contains, among other
things, komi and handicap.

   If one or both of the opponents is the computer, the field
`computer_player' is used. Otherwise it can be ignored.

   GNU Go can use a trickle file to continuously save all the moves of
an ongoing game. This file can also contain information about internal
state of the engine such as move reasons for various locations or move
valuations. The name of this file should be stored in `outfilename' and
the file pointer to the open file is stored in `outfile'. If no trickle
file is used, `outfilename[0]' will contain a null character and
`outfile' will be set to `NULL'.

Functions which manipulate a Gameinfo
-------------------------------------

   All the functions in the engine that manipulate Gameinfos have names
prefixed by `gameinfo_'.  Here is a complete list, as prototyped in
`gnugo.h':

   * `void gameinfo_clear(Gameinfo *ginfo, int boardsize, float komi)'

          Initialize the `Gameinfo' structure.

   * `void gameinfo_print(Gameinfo *ginfo)'

          Print a gameinfo.

   * `void gameinfo_load_sgfheader(Gameinfo *gameinfo, SGFNode *head)'

          Reads header info from sgf structure and sets the appropriate
          variables.

   * `void gameinfo_play_move(Gameinfo *ginfo, int i, int j, int color)'

          Make a move in the game. Return 1 if the move was legal. In
          that case the move is actually done. Otherwise return 0.

   * `int gameinfo_play_sgftree_rot(Gameinfo *gameinfo, SGFNode *head,
     const char *untilstr, int orientation)'

          Play the moves in an SGF tree. Walk the main variation,
          actioning the properties into the playing board. Returns the
          color of the next move to be made. Head is an sgf tree.
          Untilstr is an optional string of the form either 'L12' or
          '120' which tells it to stop playing at that move or move
          number. When debugging, this is the location of the move
          being examined.

   * `int gameinfo_play_sgftree(Gameinfo *gameinfo, SGFNode *head,
     const char *untilstr)'

          Same as previous function, using standard orientation.


File: gnugo.info,  Node: Utility Functions,  Next: API,  Prev: DFA,  Up: Top

Utility Functions
*****************

   In this Chapter, we document some of the utilities which may be
called from the GNU Go engine.

* Menu:

* General Utilities::              Utilities from `engine/utils.c'
* Print Utilities::                Utilities from `engine/printutils.c'
* Board Utilities::                Utilities from `engine/board.c'
* Influence Utilities::		   Utilities from `engine/influence.c'


File: gnugo.info,  Node: General Utilities,  Next: Print Utilities,  Up: Utility Functions

General Utilities
=================

   Utility functions from `engine/utils.c'. Many of these functions
underlie autohelper functions (*note Autohelper Functions::).

   * `void change_dragon_status(int dr, int status)'

          Change the status of all the stones in the dragon at `dr'.

   * `int defend_against(int move, int color, int apos)'

          Check whether a move at `move' stops the enemy from playing
          at (apos).

   * `int cut_possible(int pos, int color)'

          Returns true if `color' can cut at `pos', or if connection
          through `pos' is inhibited. This information is collected by
          `find_cuts()', using the B patterns in the connections
          database.

   * `int does_attack(int move, int str)'

          returns true if the move at `move' attacks `str'. This means
          that it captures the string, and that `str' is not already
          dead.

   * `int does_defend(int move, int str)'

          `does_defend(move, str)' returns true if the move at `move'
          defends `str'. This means that it defends the string, and that
          `str' can be captured if no defense is made.

   * `int somewhere(int color, int last_move, ...)'

          Example: `somewhere(WHITE, 2, apos, bpos, cpos)'.  Returns
          true if one of the vertices listed satisfies
          `board[pos]==color'. Here num_moves is the number of moves
          minus one.  If the check is true the dragon is not allowed to
          be dead. This check is only valid if `stackp==0'.

   * `int visible_along_edge(int color, int apos, int bpos)'

          Search along the edge for the first visible stone. Start at
          apos and move in the direction of bpos. Return 1 if the first
          visible stone is of the given color. It is required that apos
          and bpos are at the same distance from the edge.

   * `int test_symmetry_after_move(int move, int color, int strict)'

          Is the board symmetric (or rather antisymmetric) with respect
          to mirroring in tengen after a specific move has been played?
          If the move is PASS_MOVE, check the current board.  If strict
          is set we require that each stone is matched by a stone of
          the opposite color at the mirrored vertex. Otherwise we only
          require that each stone is matched by a stone of either color.

   * `int play_break_through_n(int color, int num_moves, ...)'

          The function `play_break_through_n()' plays a sequence of
          moves, alternating between the players and starting with
          color. After having played through the sequence, the three
          last coordinate pairs gives a position to be analyzed by
          `break_through()', to see whether either color has managed to
          enclose some stones and/or connected his own stones. If any
          of the three last positions is empty, it's assumed that the
          enclosure has failed, as well as the attempt to connect. If
          one or more of the moves to play turns out to be illegal for
          some reason, the rest of the sequence is played anyway, and
          `break_through()' is called as if nothing special happened.
          Like `break_through()', this function returns 1 if the
          attempt to break through was succesful and 2 if it only
          managed to cut through.

   * `int play_attack_defend_n(int color, int do_attack, int num_moves,
     ...)'

   * `int play_attack_defend2_n(int color, int do_attack, int
     num_moves, ...)'

          The function `play_attack_defend_n()' plays a sequence of
          moves, alternating between the players and starting with
          `color'. After having played through the sequence, the last
          coordinate pair gives a target to attack or defend, depending
          on the value of do_attack.  If there is no stone present to
          attack or defend, it is assumed that it has already been
          captured. If one or more of the moves to play turns out to be
          illegal for some reason, the rest of the sequence is played
          anyway, and attack/defense is tested as if nothing special
          happened. Conversely, `play_attack_defend2_n()' plays a
          sequence of moves, alternating between the players and
          starting with `color'. After having played through the
          sequence, the two last coordinate pairs give two targets to
          simultaneously attack or defend, depending on the value of
          do_attack. If there is no stone present to attack or defend,
          it is assumed that it has already been captured. If one or
          more of the moves to play turns out to be illegal for some
          reason, the rest of the sequence is played anyway, and
          attack/defense is tested as if nothing special happened.  A
          typical use of these functions is to set up a ladder in an
          autohelper and see whether it works or not.

   * `int play_connect_n(int color, int do_connect, int num_moves, ...)'

          Plays a sequence of moves, alternating between the players
          and starting with `color'. After having played through the
          sequence, the two last coordinates give two targets that
          should be connected or disconnected, depending on the value
          of do_connect. If there is no stone present to connect or
          disconnect, it is assumed that the connection has failed. If
          one or more of the moves to play turns out to be illegal for
          some reason, the rest of the sequence is played anyway, and
          connection/disconnection is tested as if nothing special
          happened.  Ultimately the connection is decided by the
          functions `string_connect' and `disconnect' (*note Connection
          Reading::).

   * `void set_depth_values(int level)'

          It is assumed in reading a ladder if `stackp >= depth' that
          as soon as a bounding stone is in atari, the string is safe.
          Similar uses are made of the other depth parameters such as
          `backfill_depth' and so forth. In short, simplifying
          assumptions are made when `stackp' is large. Unfortunately
          any such scheme invites the "horizon effect," in which a
          stalling move is perceived as a win, by pushing the
          refutation past the "horizon"--the value of `stackp' in which
          the reading assumptions are relaxed. To avoid the depth it is
          sometimes necessary to increase the depth parameters. This
          function can be used to set the various reading depth
          parameters. If `mandated_depth_value' is not -1 that value is
          used; otherwise the depth values are set as a function of
          level. The parameter `mandated_depth_value' can be set at the
          command line to force a particular value of depth; normally
          it is -1.

   * `void modify_depth_values(int n)'

          Modify the various tactical reading depth parameters. This is
          typically used to avoid horizon effects. By temporarily
          increasing the depth values when trying some move, one can
          avoid that an irrelevant move seems effective just because
          the reading hits a depth limit earlier than it did when
          reading only on relevant moves.

   * `void increase_depth_values(void)'

          `modify_depth_values(1)'.

   * `void decrease_depth_values(void)'

          `modify_depth_values(-1)'.

   * `void restore_depth_values()'

          Sets `depth' and so forth to their saved values.

   * `void set_temporary_depth_values(int d, int b, int b2, int bc, int
     ss, int br, int f, int k)'

          Explicitly set the depth values. This function is currently
          never called.

   * `int confirm_safety(int move, int color, int *defense_point, char
     safe_stones[BOARDMAX])'

          Check that the move at color doesn't involve any kind of
          blunder, regardless of size.

   * `float blunder_size(int move, int color, int *defense_point, char
     safe_stones[BOARDMAX])'

          This function will detect some blunders. If the move reduces
          the number of liberties of an adjacent friendly string, there
          is a danger that the move could backfire, so the function
          checks that no friendly worm which was formerly not
          attackable becomes attackable, and it checks that no opposing
          worm which was not defendable becomes defendable.  It returns
          the estimated size of the blunder, or 0.0 if nothing bad has
          happened.  The array `safe_stones[]' contains the stones that
          are supposedly safe after `move'. It may be `NULL'. For use
          when called from `fill_liberty()', this function may
          optionally return a point of defense, which, if taken, will
          presumably make the move at `move' safe on a subsequent turn.

   * `int double_atari(int move, int color, float *value, char
     safe_stones[BOARDMAX])'

          Returns true if a move by (color) fits the following shape:
                   X*        (O=color)
                   OX
          capturing one of the two `X' strings. The name is a slight
          misnomer since this includes attacks which are not
          necessarily double ataris, though the common double atari is
          the most important special case. If `safe_stones != NULL',
          then only attacks on stones marked as safe are tried. The
          value of the double atari attack is returned in value (unless
          value is `NULL'), and the attacked stones are marked unsafe.

   * `void unconditional_life(int unconditional_territory[BOARDMAX],
     int color)'

          Find those worms of the given color that can never be
          captured, even if the opponent is allowed an arbitrary number
          of consecutive moves. The coordinates of the origins of these
          worms are written to the worm arrays and the number of
          non-capturable worms is returned.  The algorithm is to cycle
          through the worms until none remains or no more can be
          captured. A worm is removed when it is found to be
          capturable, by letting the opponent try to play on all its
          liberties. If the attack fails, the moves are undone. When no
          more worm can be removed in this way, the remaining ones are
          unconditionally alive.  After this, unconditionally dead
          opponent worms and unconditional territory are identified. To
          find these, we continue from the position obtained at the end
          of the previous operation (only unconditionally alive strings
          remain for color) with the following steps:

            1. Play opponent stones on all liberties of the
               unconditionally alive strings except where illegal.
               (That the move order may determine exactly which
               liberties can be played legally is not important. Just
               pick an arbitrary order).

            2. Recursively extend opponent strings in atari, except
               where this would be suicide.

            3. Play an opponent stone anywhere it can get two empty
               neighbors. (I.e. split big eyes into small ones).

            4. an opponent stone anywhere it can get one empty
               neighbor. (I.e. reduce two space eyes to one space eyes.)
               Remaining opponent strings in atari and remaining
               liberties of the unconditionally alive strings
               constitute the unconditional territory.  Opponent
               strings from the initial position placed on
               unconditional territory are unconditionally dead.  On
               return, `unconditional_territory[][]' is 1 where color
               has unconditionally alive stones, 2 where it has
               unconditional territory, and 0 otherwise.

   * `void who_wins(int color, FILE *outfile)'

          Score the game and determine the winner

   * `void find_superstring(int str, int *num_stones, int *stones)'

          Find the stones of an extended string, where the extensions
          are through the following kinds of connections:
            1. Solid connections (just like ordinary string).
                        OO

            2. Diagonal connection or one space jump through an
               intersection where an opponent move would be suicide or
               self-atari.
                        ...
                        O.O
                        XOX
                        X.X

            3. Bamboo joint.
                        OO
                        ..
                        OO

            4. Diagonal connection where both adjacent intersections
               are empty.
                        .O
                        O.

            5. Connection through adjacent or diagonal tactically
               captured stones.  Connections of this type are omitted
               when the superstring code is called from reading.c, but
               included when the superstring code is called from owl.c

   * `void find_superstring_liberties(int str, int *num_libs, int
     *libs, int liberty_cap)'

          This function computes the superstring at `str' as described
          above, but omitting connections of type 5. Then it constructs
          a list of liberties of the superstring which are not already
          liberties of `str'.  If `liberty_cap' is nonzero, only
          liberties of substrings of the superstring which have fewer
          than `liberty_cap' liberties are generated.

   * `void find_proper_superstring_liberties(int str, int *num_libs,
     int *libs, int liberty_cap)'

          This function is the same as find_superstring_liberties, but
          it omits those liberties of the string `str', presumably
          since those have already been treated elsewhere.  If
          `liberty_cap' is nonzero, only liberties of substrings of the
          superstring which have at most `liberty_cap' liberties are
          generated.

   * `void find_superstring_stones_and_liberties(int str, int
     *num_stones, int *stones, int *num_libs, int *libs, int
     liberty_cap)'

          This function computes the superstring at `str' as described
          above, but omitting connections of type 5. Then it constructs
          a list of liberties of the superstring which are not already
          liberties of `str'. If liberty_cap is nonzero, only liberties
          of substrings of the superstring which have fewer than
          liberty_cap liberties are generated.

   * `void superstring_chainlinks(int str, int *num_adj, int
     adjs[MAXCHAIN], int liberty_cap)'

          analogous to chainlinks, this function finds boundary chains
          of the superstring at `str', including those which are
          boundary chains of `str' itself. If `liberty_cap != 0', only
          those boundary chains with `<= liberty_cap' liberties are
          reported.

   * `void proper_superstring_chainlinks(int str, int *num_adj, int
     adjs[MAXCHAIN], int liberty_cap)'

          analogous to chainlinks, this function finds boundary chains
          of the superstring at `str', omitting those which are
          boundary chains of `str' itself. If `liberty_cap != 0', only
          those boundary chains with `<= liberty_cap' liberties are
          reported.

   * `void start_timer(int n)'

          Start a timer. GNU Go has four internal timers available for
          assessing the time spent on various tasks.

   * `double time_report(int n, const char *occupation, int move,
     double mintime)'

          Report time spent and restart the timer. Make no report if
          elapsed time is less than mintime.


File: gnugo.info,  Node: Print Utilities,  Next: Board Utilities,  Prev: General Utilities,  Up: Utility Functions

Print Utilities
===============

   Functions in `engine/printutils.c' do formatted printing similar to
`printf' and its allies.  The following formats are recognized:

   * `%c', `%d', `%f', `%s', `%x'

          These have their usual meaning in formatted output, printing
          a character, integer, float, string or hexadecimal,
          respectively.

   * `%o'

          `Outdent.' Normally output is indented by `2*stackp' spaces,
          so that the depth can be seen at a glance in traces. At the
          beginning of a format, this `%o' inhibits the indentation.

   * `%H'

          Print a hashvalue.

   * `%C'

          Print a color as a string.

   * `%m', `%2m' (synonyms)

          Takes 2 integers and writes a move, using the two dimensional
          board representation (*note The Board Array::)

   * `%1m'

          Takes 1 integers and writes a move, using the one dimensional
          board representation (*note The Board Array::)

   We list the non statically declared functions in `printutils.c'.

   * `void gfprintf(FILE *outfile, const char *fmt, ...)'

          Formatted output to `outfile'.

   * `int gprintf(const char *fmt, ...)'

          Formatted output to stderr. Always returns 1 to allow use in
          short-circuit logical expressions.

   * `int mprintf(const char *fmt, ...)'

          Formatted output to stdout.

   * `DEBUG(level, fmt, args...)'

          If `level & debug', do formatted output to stderr. Otherwise,
          ignore.

   * `void abortgo(const char *file, int line, const char *msg, int
     pos)'

          Print debugging output in an error situation, then exit.

   * `const char * color_to_string(int color)'

          Convert a color value to a string

   * `const char * location_to_string(int pos)'

          Convert a location to a string

   * `void location_to_buffer(int pos, char *buf)'

          Convert a location to a string, writing to a buffer.

   * `int string_to_location(int boardsize, char *str, int *m, int *n)'

          Get the `(m, n)' coordinates in the standard GNU Go
          coordinate system from the string `str'.  This means that `m'
          is the nth row from the top and `n' is the column. Both
          coordinates are between 0 and `boardsize-1', inclusive.
          Return 1 if ok, otherwise return 0;

   * `int is_hoshi_point(int m, int n)' True if the coordinate is a
     hoshi point.

   * `void draw_letter_coordinates(FILE *outfile)' Print a line with
     coordinate letters above the board.

   * `void simple_showboard(FILE *outfile)'

          Bare bones version of `showboard(0)'. No fancy options, no
          hint of color, and you can choose where to write it.

   The following functions are in `showbord.c'. Not all public
functions in that file are listed here.

   * `void showboard(int xo)'

          Show go board.
               xo=0:      black and white XO board for ascii game
               xo=1:      colored dragon display
               xo=2:      colored eye display
               xo=3:      colored owl display
               xo=4:      colored matcher status display

   * `const char * status_to_string(int status)'

          Convert a status value to a string.

   * `const char * safety_to_string(int status)'

          Convert a safety value to a string.

   * `const char * result_to_string(int result)'

          Convert a read result to a string


File: gnugo.info,  Node: Board Utilities,  Next: Influence Utilities,  Prev: Print Utilities,  Up: Utility Functions

Board Utilities
===============

   The functions documented in this section are from `board.c'. Other
functions in `board.c' are described in *Note Some Board Functions::.

   * `void store_board(struct board_state *state)'

          Save board state.

   * `void restore_board(struct board_state *state)'

          Restore a saved board state.

   * `void clear_board(void)'

          Clear the internal board.

   * `void dump_stack(void)'

          for use under gdb prints the move stack.

   * `void add_stone(int pos, int color)'

          Place a stone on the board and update the board_hash. This
          operation destroys all move history.

   * `void remove_stone(int pos)'

          Remove a stone from the board and update the board_hash. This
          operation destroys the move history.

   * `int is_pass(int pos)'

          Test if the move is a pass or not.  Return 1 if it is.

   * `int  is_legal(int pos, int color)'

          Determines whether the move `color' at `pos' is legal.

   * `int  is_suicide(int pos, int color)'

          Determines whether the move `color' at `pos' would be a
          suicide.  This is the case if
            1. There is no neighboring empty intersection.

            2. There is no neighboring opponent string with exactly one
               liberty.

            3. There is no neighboring friendly string with more than
               one liberty.

   * `int is_illegal_ko_capture(int pos, int color)'

          Determines whether the move `color' at `pos' would be an
          illegal ko capture.

   * `int is_edge_vertex(int pos)'

          Determine whether vertex is on the edge.

   * `int edge_distance(int pos)'

          Distance to the edge.

   * `int is_corner_vertex(int pos)'

          Determine whether vertex is a corner.

   * `int get_komaster()'

   * `int get_kom_pos()'

          Public functions to access the variable `komaster' and
          `kom_pos', which are static in `board.c'.

   Next we come to `countlib()' and its allies, which address the
problem of determining how many liberties a string has. Although
`countlib()' addresses this basic question, other functions can often
get the needed information more quickly, so there are a number of
different functions in this family.

   * `int countlib(int str)'

          Count the number of liberties of the string at `pos'. There
          must be a stone at this location.

   * `int findlib(int str, int maxlib, int *libs)'

          Find the liberties of the string at `str'. This location must
          not be empty. The locations of up to maxlib liberties are
          written into `libs[]'. The full number of liberties is
          returned.  If you want the locations of all liberties,
          whatever their number, you should pass `MAXLIBS' as the value
          for `maxlib' and allocate space for `libs[]' accordingly.

   * `int fastlib(int pos, int color, int ignore_captures)'

          Count the liberties a stone of the given color would get if
          played at `pos'. The intent of this function is to be as fast
          as possible, not necessarily complete. But if it returns a
          positive value (meaning it has succeeded), the value is
          guaranteed to be correct. Captures are ignored based if the
          `ignore_captures' field is nonzero. The location `pos' must
          be empty.  The function fails if there are more than two
          neighbor strings of the same color.  In this case, the return
          value is -1.  Captures are handled in a very limited way, so
          if ignore_capture is 0, and a capture is required, it will
          often return -1.

   * `int approxlib(int pos, int color, int maxlib, int *libs)'

          Find the liberties a stone of the given color would get if
          played at `pos', ignoring possible captures of opponent
          stones.  The location `pos' must be empty. If `libs != NULL',
          the locations of up to `maxlib' liberties are written into
          `libs[]'. The counting of liberties may or may not be halted
          when `maxlib' is reached. The number of liberties found is
          returned, which may be less than the total number of
          liberties if `maxlib' is small. If you want the number or the
          locations of all liberties, however many they are, you should
          pass `MAXLIBS' as the value for maxlib and allocate space for
          `libs[]' accordingly.

   * `int accuratelib(int pos, int color, int maxlib, int *libs)'

          Find the liberties a stone of the given color would get if
          played at `pos'. This function takes into consideration all
          captures. Its return value is exact in that sense it counts
          all the liberties, unless `maxlib' allows it to stop earlier.
          The location `pos' must be empty. If `libs != NULL', the
          locations of up to `maxlib' liberties are written into
          `libs[]'. The counting of liberties may or may not be halted
          when `maxlib' is reached. The number of found liberties is
          returned.  This function guarantees that liberties which are
          not results of captures come first in `libs[]' array. To find
          whether all the liberties starting from a given one are
          results of captures, one may use `if (board[libs[k]] !=
          EMPTY)' construction.  If you want the number or the
          locations of all liberties, however many they are, you should
          pass `MAXLIBS' as the value for `maxlib' and allocate space
          for `libs[]' accordingly.

   Next we have some general utility functions.

   * `int count_common_libs(int str1, int str2)'

          Find the number of common liberties of the two strings.

   * `int find_common_libs(int str1, int str2, int maxlib, int *libs)'

          Find the common liberties of the two strings. The locations
          of up to `maxlib' common liberties are written into `libs[]'.
          The full number of common liberties is returned.  If you
          want the locations of all common liberties, whatever their
          number, you should pass `MAXLIBS' as the value for `maxlib'
          and allocate space for `libs[]' accordingly.

   * `int have_common_lib(int str1, int str2, int *lib)'

          Determine whether two strings have at least one common
          liberty.  If they do and `lib != NULL', one common liberty is
          returned in `*lib'.

   * `int countstones(int str)'

          Report the number of stones in a string.

   * `int findstones(int str, int maxstones, int *stones)'

          Find the stones of the string at `str'. The location must not
          be empty. The locations of up to maxstones stones are written
          into `stones[]'. The full number of stones is returned.

   * `int  chainlinks(int str, int adj[MAXCHAIN])'

          This very useful function returns (in the `adj' array) the
          chains surrounding the string at `str'. The number of chains
          is returned.

   * `int chainlinks2(int str, int adj[MAXCHAIN], int lib)'

          Returns (in `adj' array) those chains surrounding the string
          at `str', which has exactly `lib' liberties. The number of
          such chains is returned.

   * `int chainlinks3(int str, int adj[MAXCHAIN], int lib)'

          Returns (in `adj' array) the chains surrounding the string at
          `str', which have less or equal `lib' liberties.  The number
          of such chains is returned.

   * `int extended_chainlinks(int str, int adj[MAXCHAIN], int
     both_colors)'

          Returns (in the `adj' array) the opponent strings being
          directly adjacent to `str' or having a common liberty with
          `str'. The number of such strings is returned.  If the
          both_colors parameter is true, also own strings sharing a
          liberty are returned.

   * `int find_origin(int str)'

          Find the origin of a string, i.e. the point with the smallest
          1D board coordinate. The idea is to have a canonical
          reference point for a string.

   * `int is_self_atari(int pos, int color)'

          Determine whether a move by color at `pos' would be a self
          atari, i.e. whether it would get more than one liberty. This
          function returns true also for the case of a suicide move.

   * `int liberty_of_string(int pos, int str)'

          Returns true if `pos' is a liberty of the string at `str'.

   * `int second_order_liberty_of_string(int pos, int str)'

          Returns true if `pos' is a second order liberty of the string
          at str.

   * `int neighbor_of_string(int pos, int str)'

          Returns true if `pos' is adjacent to the string at `str'.

   * `int has_neighbor(int pos, int color)'

          Returns true if `pos' has a neighbor of `color'.

   * `int same_string(int str1, int str2)'

          Returns true if `str1' and `str2' belong to the same string.

   * `int adjacent_strings(int str1, int str2)'

          Returns true if the strings at `str1' and `str2' are adjacent.

   * `int is_ko(int pos, int color, int *ko_pos)'

          Return true if the move `pos' by `color' is a ko capture
          (whether capture is legal on this move or not). If so, and if
          `ko_pos' is not a `NULL' pointer, then `*ko_pos' returns the
          location of the captured ko stone.  If the move is not a ko
          capture, `*ko_pos' is set to 0.  A move is a ko capture if
          and only if
            1. All neighbors are opponent stones.

            2. The number of captured stones is exactly one.

   * `int is_ko_point(int pos)'

          Return true if `pos' is either a stone, which if captured
          would give ko, or if `pos' is an empty intersection adjacent
          to a ko stone.

   * `int does_capture_something(int pos, int color)'

          Returns 1 if at least one string is captured when color plays
          at `pos'.

   * `void mark_string(int str, char mx[BOARDMAX], char mark)'

          For each stone in the string at pos, set `mx' to value mark.
          If some of the stones in the string are marked prior to
          calling this function, only the connected unmarked stones
          starting from pos are guaranteed to become marked. The rest
          of the string may or may not become marked. (In the current
          implementation, it will.)

   * `int move_in_stack(int pos, int cutoff)'

          Returns true if at least one move has been played at pos at
          deeper than level `cutoff' in the reading tree.

   * `int stones_on_board(int color)'

          Return the number of stones of the indicated color(s) on the
          board.  This only counts stones in the permanent position,
          not stones placed by `trymove()' or `tryko()'. Use
          `stones_on_board(BLACK | WHITE)' to get the total number of
          stones on the board.


File: gnugo.info,  Node: Influence Utilities,  Prev: Board Utilities,  Up: Utility Functions

Utilities from `engine/influence.c'
===================================

   We will only list here a portion of the public functions in
`influence.c'.  The influence code is invoked through the function
`compute_influence' (*note Influence Usage::). It is invoked as follows.

   * `void compute_influence(int color, const char
     safe_stones[BOARDMAX], const float strength[BOARDMAX], struct
     influence_data *q, int move, const char *trace_message)'

          Compute the influence values for both colors.  The caller must
             - set up the `board[]' state

             - mark safe stones with `INFLUENCE_SAFE_STONE', dead
               stones with 0

             - mark stones newly saved by a move with
               `INFLUENCE_SAVED_STONE' (this is relevant if the
               influence_data *q is reused to compute a followup value
               for this move).
          Results will be stored in q.  `move' has no effects except
          toggling debugging. Set it to -1 for no debug output at all
          (otherwise it will be controlled by the `-m' command line
          option). It is assumed that `color' is in turn to move. (This
          affects the barrier patterns (class A, D) and intrusions
          (class B)). Color

   Other functions in `influence.c' are of the nature of utilities
which may be useful throughout the engine. We list the most useful ones
here.

   * `void influence_mark_non_territory(int pos, int color)'

          Called from actions for `t' patterns in `barriers.db'.  Marks
          `pos' as not being territory for `color'.

   * `int whose_territory(const struct influence_data *q, int pos)'

          Return the color of the territory at `pos'. If it's territory
          for neither color, `EMPTY' is returned.

   * `int whose_moyo(const struct influence_data *q, int pos)'

          Return the color who has a moyo at `pos'. If neither color
          has a moyo there, `EMPTY' is returned. The definition of moyo
          in terms of the influences is totally ad hoc.

   * `int whose_area(const struct influence_data *q, int pos)'

          Return the color who has dominating influence ("area") at
          `pos'.  If neither color dominates the influence there, EMPTY
          is returned.  The definition of area in terms of the
          influences is totally ad hoc.


File: gnugo.info,  Node: GTP,  Next: Regression,  Prev: API,  Up: Top

The Go Text Protocol
********************

* Menu:

* The Go Text Protocol::          The Go Text Protocol
* Running in GTP mode::           Running GNU Go in GTP mode
* GTP applications::              GTP applications
* The Metamachine::               The Metamachine
* Adding new GTP commands::       Adding new GTP commands
* GTP command reference::         Details on every GTP command


File: gnugo.info,  Node: The Go Text Protocol,  Next: Running in GTP mode,  Up: GTP

The Go Text Protocol
====================

   GNU Go 3.0 introduced a new interface, the Go Text Protocol,
abbreviated GTP. The intention was to make an interface that is better
suited for machine-machine communication than the ascii interface and
simpler, more powerful, and more flexible than the Go Modem Protocol.

   There are two versions of the protocol. Version 1 was used with GNU
Go 3.0 and 3.2. GNU Go 3.4 and later versions use protocol version 2.
The specification of GTP version 2 is available at
<http://www.lysator.liu.se/~gunnar/gtp/>. GNU Go 3.4 is the reference
implementation for GTP version 2, but all but the most common commands
are to be regarded as private extensions of the protocol.

   The GTP has a variety of applications. For GNU Go the first use was
in regression testing (*note Regression::), followed by communication
with the NNGS go server and for automated test games against itself and
other programs. Now there are also many graphical user interfaces
available supporting GTP, as well as bridges to other Go servers than
NNGS.

